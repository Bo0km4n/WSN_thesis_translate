# Abstract
センサネットワークの将来のアプリケーションに直面する根本的な問題は、特定のデータ項目を格納するセンサノードを効率的に配置する方法です。

分散ハッシュテーブル（DHT）ベースのインターネットピアツーピア（P2P）プロトコルは、分散ノードのネットワーク上で行われた照会に最適なデータ検索時間を提供することが知られている[2、23-25]。
しかしながら、これらのプロトコルのセンサネットワークへの一般的なマッピングは困難であると認識されている[1]。

我々はセンサネットワーク（CSN）のための新しいDHTベースのネットワークプロトコルを提示している.Odd（logN）メッセージのオーダーでデータ検索のための有界時間をエネルギー効率の良い方法で達成することができる。
CSNは、センサネットワークのシステム寿命をその有効使用に比例させる。 さらに、CSNは、センサノードの数の増加に伴って他のノードに関する情報が対数的に増加する場合に、大規模センサネットワークに適している。

# Introduction
IC製造、RF設計、MEMSベースの技術の進歩により、開発コストの低い単一のチップにDSPとセンシングを統合することが可能になりました
[9-10]。
これらのチップまたはセンサは、物理現象を観察し、その現象に関するデータを関心のある観察者に報告する。
センサは、一般に、センシングハードウェア、メモリ、バッテリ、エンベデッドプロセッサ、およびトランシーバからなる[14]。
センサネットワーク（SN）と呼ばれるこれらのセンサネットワークは、信頼性、スケーラビリティ、耐障害性、および物理現象の正確なモニタリングを提供することによって、物理的および計算的世界の間のギャップを埋める。
信頼性の高い位置追跡、戦場監視、生息地監視、機械予後、バイオセンシングなど、SNの多くのアプリケーションがあります[11,12]。
アーキテクチャの観点から見ると、SNの構成は、物理層、ネットワーク層、アプリケーション層で構成されています[13]。

これまでの研究では、通常、センサーが一定の割合でデータを報告すると仮定しています[17-20]。
そのような予めプログラムされたセンサのための最適なネットワーク層プロトコルはよく知られており[3-6]、センサネットワークを照会する領域ははるかに少ない。これらのセンサーはデータを保存せず、特定の時間間隔後にデータを報告するように予めプログラムされています。
この前提の欠点は、エンドユーザが重大なオーバーヘッドを引き起こすことなく、その場でシステムの動作を変更できないことです[15]。
さらに、ユーザからの実際のクエリが頻繁でない場合、ユーザが必要としないデータを送信する際に、かなりのバッテリ電力が無駄になる。
一定の割合でデータを報告するのではなく、ユーザのクエリに応答してのみデータを報告するセンサは、これらの問題を克服し、他のものは一定であり、システムの有効期間を有効な使用に比例させる。
SN [15-16]のクエリを支援するためにデータベースコミュニティから概念を適用しようとする試みがありましたが、これらの概念はアプリケーション層に適用でき、我々の作業の焦点はクエリのネットワーク層のサポートにあります。

DHTベースのネットワークプロトコルを使用してSNでクエリを処理することは、a）
レイテンシ、システムライフタイム、スケーラビリティ、フォールトトレランスなどのパフォーマンスメトリックの観点から、既存のSNモデルを上回る可能性があります。b）
SNでデータ検索の時間を制限することができ、その上で実行されるアプリケーションに保証を与えることができます。
しかしながら、これらのプロトコルは、通常、DHT論理識別子空間内の近隣ノードが隣接ノードと通信することができないように、エネルギ拘束センサネットワークには適していない物理ネットワークトポロジにおけるそれらの近接性とは無関係にノードを相互接続する。実際には遠く離れており、DHT内の各論理ホップは多くのパケット伝送のエネルギーを消費する可能性があります[1] b）
特に、大規模なSNでは、エネルギーが制限されたSN環境では、すべてのノードペア間でルーティング情報を維持することはコスト高となる[1]。c）インターネット内の各ノードの一意のIPアドレスを使用して、 DHTインターネットプロトコル[2、23-25]で必要とされているが、個々のセンサは一般的にSNで名前が付けられておらず、各センサに固有のIPアドレスの概念はない。

本稿では、DHTベースのネットワーク層プロトコルCSNを提案する。このCSNは、動的照会のためにデータルックアップの時間をSNで実現することができる。
我々は、CSNが上記のすべての問題を処理し、SN研究を一歩前進させることを示します。
CSNは、データルックアップをサポートするインターネットピアツーピア（P2P）システムであるChord [2]の設計原則に従います。
CSNは階層的クラスタリングアプローチです。 CSNの各クラスタは論理的なリング形成で形成される。
各CSNセンサノードは、O（logN）のフィンガテーブルをリング内の他のノードに保持し、O（ログN）メッセージを他のノードに送信することによってすべてのルックアップを解決する。

論文の残りは以下のように編成されている。 セクション2は、センサネットワークに関する簡単な背景を提供する。
セクション3はCSNにつながるSNプロトコル進化を特定し、セクション4はいくつかの技術的なトレードオフを概説する。
セクション5は、CSNプロトコルを詳細に提示する。 セクション6は、シミュレーションとテストの結果を示します。
今後の作業について概要を述べ、第7章で結論を要約する。

# Background on Sensor networks

インターネットと本質的に異なるSN環境は、システム研究者にいくつかのユニークな課題を提起します.
センサネットワーク（例えば、線形またはグリッド配置）の系統的展開は一般的ではない。
アドホック・デプロイメントは、センサ自体がディストリビューションに対処して通信経路を形成できることを意味します。
センサが配備されると、センサは無人のままであり、従って全ての動作SN内のトポロジ管理、データ管理などは自動的に行われるべきであり、手動または遠隔支援を必要とすべきではない。
さらに、センサネットワークが展開される環境は、事実上敵対的であり、動的である。
したがって、SNは適応性があり、ノードまたは通信障害に対処できる必要があります。
SN内のセンサーは、エネルギーが制約され、バッテリーの電力が計算と通信を実行するには不十分であると、死んだものとみなされます。
このため、ネットワークプロトコルはエネルギー消費のために最適化する必要があります。
限られたエネルギーに加えて、センサに利用可能な帯域幅も限られており、したがって、大量のデータを通信することができない。
データ配信方法に基づいて、センサネットワークは、[14]として分類することができる。 a）連続：センサは、それらのデータを一定の速度で基地局に通信する。b）イベント駆動型：センサは、関心のあるイベントが発生した場合にのみ情報を報告する。c）
オブザーバー開始：センサーは、ユーザーからの明示的な照会に対する応答としてのみデータを報告します。

# Related Work
従来のフラッディングと同様に、各ノードがネットワーク内にデータをフラッディングすると、ノードは2つ以上の異なるパスから同じ情報を受け取ることができます。 いわゆる爆縮問題である。
オーバーラップとして知られている別の問題は、2つ以上のセンサの地理的監視領域が重なったときに発生します。
そのようなセンサーからの情報には、共通の情報がいくつかあります。
SPIN [17]の主な貢献は、爆縮とオーバーラップによって引き起こされる重複情報転送を克服することである。
SPINはメタデータキーを使用してデータを記述します。
これらのメタデータキーは、一意のデータに対して一意であり、異なるノードからの同様のデータについても同じである。
すべてのSPINノードは、これらの通知に基づいて、ノードが要求していないデータのみを要求するメタデータキーをアドバタイズします。
CSNはSPINと同様に爆縮とオーバーラップの問題を克服します。

ノードとしての1つのノードを有するセンサノードのローカルクラスタリングは、ノード間のローカル調整をより効率的にするので、非クラスタリングアプローチ（例えば古典的なフラッディング）よりも優れている。
さらに、SNにおいてノードの数が増加すると、クラスタリングはスケーラビリティを増加させる可能性がある。
Estrin et al。 [18]は、クラスター階層を構築するために拡張できる2レベルのクラスター化アルゴリズムを提供しました。
この種のクラスタリングは、クラスタ・ヘッドであるという責任はクラスタ・メンバ・ノード間で回転しないため、静的クラスタリングと呼ばれます。
静的クラスタリングは、通常のノードより多くのエネルギーを消費するため、クラスタヘッドが急速に消滅する可能性があるという欠点があります。
LEACH [19]はクラスタ内のクラスタヘッドをランダムに回転させることでこの問題の解決策を提案した。
これは、クラスタヘッドの高エネルギー消費タスクをすべてのノードに分割し、結果としてSNの寿命を延ばす。

PEGASIS [20]は、LEACHと同じSN環境で提案されている。
PEGASISの各ノードは、近隣ノードに電力信号を送り、1つのノードだけが聞こえるまで徐々に電力信号を減少させることによって、最も近い近隣を識別する。
各ノードは、次に、その最も近いネイバーとのみ通信し、ラウンドロビン方式で、基地局にデータを送信するために交代する。
これにより、1ラウンドあたりのデータ送信に必要な電力が削減され、SNの寿命がさらに長くなります。
TEEN [21]では、データが送信されるべきかどうかを決定するために、検知されたデータ値がユーザ定義のしきい値と比較される。
TEENは、データ配信モデルがイベントドリブンである場合、LEACHおよび類似のプロトコルが適切でないことを示します。
この議論は、データ配信モデルがオブザーバによって開始された場合にも、これらのプロトコルが適切ではないことを提案することによって拡張されます。
指向拡散[22]は、データ配信モデルがオブザーバーによって開始されるため、上記のプロトコルとは異なります。
有向拡散では、各センサは、1つまたは複数の属性を使用して生成するデータに名前を付けます。
シンクノードは、特定のデータに関するクエリの概念と同様の関心が生成されるノードです。
中間ノードは、地理的情報を使用して各ホップでこれらの関心をデータソースに向かって局所的に伝播させる。
関心は、関心を表明したシンクに向かってデータの勾配を確立し、したがって、そのような勾配を使用してデータがシンクに送信される。
ノードがローカル知識しか有していないので、同じデータまたは同じ関心が複数の異なる経路からノードに送信される可能性がある。
これらの冗長パスを最小限に抑えるためのディレクテッド拡散が試みられますが、そのような試みの効果は最適ではありません。
CSNには、クエリの伝播とデータ配信のパスが1つしかないため、このような冗長性はありません。

指向性拡散を除く上記のプロトコルはすべて、データがSNの外部に格納され、一方、有向拡散がデータをローカルに格納すると仮定します。
GHT [1]の主な論文は、ネットワーク内のデータがデータのタイプに従って格納されていれば、データのクエリを、その名前付きデータを格納するノードに直接送ることができるということである。
この作業は、地理的位置以外のいくつかの経路情報を有することによってSNに効率的に問い合わせるという概念を使用するという点で独特である。
外部ストレージ、ローカルストレージ、データ中心のストレージのコスト分析を行い、データ中心のストレージがクエリにとって最も効率的であることを示します。
しかし、特定の制約の下では、ローカルストレージはデータ中心ストレージよりも効率的であると考えられます。

# Technichal Tradeoffs 
利用可能な多くの分散ハッシュテーブル（DHT）ベースのインターネットプロトコルおよびシステムが存在する。 Chord、CAN、Pastry、Tapestry、Freenet、Gnutella、Oceanstore、Ohahaシステム[2、23-25、7-8、27-29]。
多くのシステムとは異なり、Chordは強力な保証を提供し、そのルックアップ機能は予測可能な時間内に実行され、常に成功または確実に失敗するため、Chordの設計原則に従うことにしました。
他のいくつかのシステム、例えば。 Oceanstore [28]は、Chordよりも強力な保証を提供しますが、Chordは実質的に複雑さが少なく、並行ノード結合および障害の処理が優れています。
おそらくは敵対的なセンサネットワーク環境では、ノード障害から正常に回復することは非常に重要であり、Chordはこれを達成するための最良の選択肢でした。
さらに、Chordのスケーラビリティは、ブロードキャストの普及を促進するGnutella [27]のようなシステムでChordを選択する決定を下すのに役立つもう一つの要素でした。
クラスタ化または非クラスタ化のネットワークプロトコルを使用するかどうかを決める際には、ローカルクラスタリングというよりも、1つのノードを先頭にして多くの議論が行われず、ノード間のローカル調整が効率化され、スケーラビリティが向上します。

# The CSN Protocol
CSNには2つの操作モードがあります。エネルギー効率のよいモード（EEmode）およびロバストモード（Rmode）を含む。
我々は、センサがアドホックに配置され、基地局がセンサから遠くに位置し、データ配信モデルがオブザーバによって開始され、センサが静的である環境を考える。

### 5.1 初期設定
センサネットワークでは、各ノードは、エネルギー効率を最適化するために、最も近い隣接ノードと通信する必要があります。
リング環境の問題：各ノードの時計回りの後続ノードが地理的に最も近いセンサノードの論理リングを形成する必要があります。
私たちはNPcompleteリング問題の2つの近似解を提案します：連鎖法とセットアベレージ法（SAM）。
連鎖法は、クラスタC内の各センサαiの後続を、それに利用可能な地理的に最も近いセンサとする。
これは、αiがαi.successorと通信するときに、できるだけエネルギーを消費しないことを意味します。
この特性は、最後のセンサαmが最初のセンサα1をその後継者とするリンクを除いて、真の∀αiを保持する。
これは、鎖のαmとα1が∀αi：i = 2,3、...、m - 1に比べて素早く死ぬという問題を引き起こす。図1に示すように、チェーン・メソッドのわずかな修正でこの問題を改善できます。
リンクαm.successorを高エネルギー消費とマークし、リング内で反時計回りにメッセージをルーティングすることによってαmとα1を通信させる場合、各ホップで最小エネルギー量が消費される。

Rmodeに適した集合平均法は、各クラスタノードとすべてのメンバクラスタノードとの距離を最小化しようとします。
集合平均法は、各ノードαiの後継ノードが地理的に最も近いノードであることを保証するものではない。
Rmodeのようにこの保証は必要ではなく、αi.successorとほとんど通信しないノードではなく、論理的なリング配置でさらに離れたノードにメッセージが直接送信されます。
RmodeとEEmodeは、クラスタの設定に使用された方法に関係なく正しく動作します。
しかしながら、期待される動作モードがRモードである場合、初期設定は、設定平均法に従って行われなければならない。
同様に、期待される動作モードがチェーンモードよりもEEモードである場合には、好ましい方法であるべきである。

連鎖法：クラスター階層のレベルを0,1、...、mとし、πi= {レベルiに関与するすべてのセンサー}を設定し、δi= {現在レベルのクラスターのすべてのセンサー
i}。
最初はδi= / 0である。 さらに、π0= {すべての配置されたセンサ}。
αi=センサを考慮し、β=基地局とし、αi.successor=リング配置クラスタのαiの時計回りの後継とする。
関数min（X）はXから最小距離のセンサーを与えます。ここでXはセンサーまたは基地局のいずれかです。
min（X）関数は、PEGASIS [20]と同様の方法で最小センサーを計算します。最初にXから高電力信号を送り、1つのセンサーだけが聞こえるまで信号を徐々に減少させます。
λi=レベルiにおけるクラスタ当たりのセンサノードの最大数とし、ω=クラスタCのクラスタヘッドとする。τ=クラスタCに含まれるセンサの集合と|τ| =集合τ内の要素の数。
レベル0の連鎖法アルゴリズムを図2に示します。

集合平均法：連鎖法で定義された記号に加えて、νk=リスト、ε=集合とする。
関数min（X、M）は、上で説明した関数min（X）と同様ですが、最も近いセンサを与える代わりに、Xに最も近いMセンサのリストを与えます。
レベル0に対する集合平均法（SAM）アルゴリズムを図3に示す。

### 5.2 Cluster head rotation
LEACH [19]とは異なり、CSNのクラスターヘッドローテーションはラウンドロビン方式で行われます。 また、CSNにおけるラウンド[19]の概念はなく、一度クラスターが形成されると
初期セットアップ時間では、クラスタ形成アルゴリズムを何度も何度も実行する必要はない。 レベルiのクラスタCの各クラスタヘッドは、与えられた1つのエネルギー量子Eqを消費したときに、リングの時計回りの次の次のヘッドを次のヘッドにし、
Eq = Em /μ（1）
Em =センサの最大エネルギー、μ=定数。
μの値を増やすことによって、クラスタ頭部回転をより頻繁に行うことができ、その逆も可能である。
CSNのクラスタヘッド回転方法は、SNが非アクティブであるとき、すなわちアプリケーションからのクエリが全くないか、またはほとんどないときにヘッドの回転が起こらないという利点を有する。
さらに、回転方法は、クラスタ内の互いのメンバーノードが正確に一度ヘッドとして機能した後に、ノードがヘッドとして再割り当てされることを保証する。

### 5.3 Hierarchial Clustering
図2および図3にそれぞれ示されている連鎖法および集合平均法は、より高次の層の層を形成するために容易に使用することができる。
下位層からの各クラスタヘッドは、スーパーセンサΘiとして上位層に参加し、上位層に参加するセンサノードの総数は、階層を上るにつれて減少する。
上位レベルに参加するノードはより多くのデータを格納する必要があり、クラスタごとにより多くのノードにこのデータを分散させることがメモリの制限のため望ましい。
さらに、上位層クラスタメンバー間の地理的距離が増加するにつれて、上位層クラスタ内の隣接ノード間の地理的距離を最小化するために、クラスタごとにより多くのノードを有することが望ましい。
クラスター階層のレベルは0,1、...、m、λiはレベルiのクラスターC内のセンサーノードの最大数、Niはレベルiに関与するセンサーノードの総数である。
レベルiにおけるクラスタ数φiは、
φi= Ni /λi（2）
したがって、レイヤーごとにクラスターの総数は減少します。 CSNの階層的クラスタリング方法は、
N0> N1> ...> Nk> ...> Nm ...（3）
λ0≦λ1≦...≦λk≦...≦λm...（4）
N0 /λ0> N1 /λ1> ...> Nk /λk> ...> Nm /λm...（5）
φ0>φ1> ...>φk> ...>φm（6）

### 5.4 Energy-Efficient Mode vs. Robust Mode
ロバストモード（Rmode）で動作している間、CSNはChord [2]と同様に機能し、O（ログN）のメッセージの境界でルックアップを解決することができる。
しかし、データ検索におけるこの効率は、各ノードが可能な限り離れたノードに直接メッセージを送信しているため、エネルギー消費が大きくなるという犠牲を払って達成されます。 
Rmodeは、エネルギー効率の高いモード（EEmode）でアプリケーションの遅延要件を満たすことができない場合にのみ使用されます。
EEモードでは、メッセージをノードに送信する論理動作は、実際のルーティングから分離され、メッセージのルーティングは、各ノードがその最も近い隣接ノードのみと通信することによって行われる。

図4の例を考えてみましょう。
クラスタ形成法は、距離（α1、α4）≧距離（α1、α2）を保証する。 
したがって、α1がRmodeで起こるようにメッセージを直接α4に送ることを決定した場合、メッセージ配信におけるホップの数は最小になるが、α1とα4の両方により大きなエネルギー消費を犠牲にしている。
一方、EEmodeによれば、α1は、メッセージをα4、α2、α3にルーティングする。 メッセージ配信のホップ数はRmodeよりも大きくなりますが、各ホップで消費されるエネルギーは少なくなります。

EEmodeはデフォルトの動作モードであり、アプリケーションの遅延要件をEEモードで満たすことができない場合にのみ、CSNがRモードに切り替わります。
アプリケーション許容遅延dは、遅延閾値Γdおよびif（d≤Γd）Rmode elseEEmodeと比較されます。
純粋なRmodeを使用すると、ノードへのすべての論理メッセージがノードに直接配信されます。 
純粋なEEmodeでは、ノードへのすべての論理メッセージは間接的にルーティングされますが、 各ノードがそのメッセージを最寄りのノードに渡すことによって行われる。
EEmodeとRodeのハイブリッド形式も可能です。
ハイブリッド形式では、各ノードは、RモードまたはEモードを使用する間にローカル決定を行う。

### 5.5. Incremental Setup vs. Parallel Setup
パラレルセットアップにおけるクラスタヘッドの選択は、LEACH [19]に似ています。
各ノードαiは、乱数0≦γ≦1を選択し、（γ>Γh）αiがクラスタヘッドになることを決定すると、Γhは閾値である。
Γhは、現在のレベルiにおけるクラスタヘッドの必要数として設定される。
Γh= 0.06はクラスタヘッドとして全ノードの6％を与える。
この例では、クラスタヘッドになる確率は0.06です。
一旦クラスタヘッドが決定されると、論理リングクラスタを形成するためにchainmethodまたはset-averageのいずれかの方法を使用することができる。
一方のクラスタ形成が他方のクラスタ形成プロセスをトリガするインクリメンタルセットアップとは異なり、全てのクラスタ形成が同時に実行される.

インクリメンタルセットアップには時間がかかりますが、最適なエネルギー効率の高いクラスター形成が保証されます。
一方、パラレルセットアップはクラスタを迅速に形成しますが、クラスタヘッドがネットワーク内で均一に分散されない可能性があるため、最適なクラスタ形成が行われない可能性があります。
使用するクラスター形成のモードの決定は、アプリケーション固有のものです。

定理5.1インクリメンタルセットアップを用いた連鎖法はO（N）時間を要する。 N =ネットワーク内のセンサーの総数。

証明：クラスター階層のレベルを0,1、...、m、λiをレベルiのクラスターあたりのセンサーの最大数とし、Niをレベルiに関与するセンサーの総数とする。
連鎖法アルゴリズムから、任意のクラスタCを形成する際に、各ノードαi∈Cには一度だけ接触することが分かっている。
したがって、レベルiにおける∀C、1つのCを形成するのに要する時間tj =λiとする。
レベルiのクラスタを1,2、...、pとする。式2から、レベルiにおけるクラスターの数、φi= Ni /λi。したがって、

Ti =pΣj= 1 * tj =λi×Ni /λi= Ni。

合計時間=mΣi= 1 * Ti = N0 + N1 + ... + Nk + ... + Nm。

ここで、Nmはクラスター階層の最高レベルに関与するセンサーの数を表し、Tiはレベルiのすべてのクラスターを形成する時間を表します。
式3から、N0> N1> ...> Nk> ...> Nmであることがわかります。このため、

O（N0 + N1 + ... + Nk + ... + Nm）≒O（N0）

As、レベル0で：N0 = N、それゆえ、チェインメソッド= O（N）によるインクリメンタルセットアップによって要する時間は、

定理5.2インクリメンタルセットアップを用いたセット平均法はO（N）時間かかる。 N =ネットワーク内のセンサーの総数。

証明：集合平均法では、各センサαiは2回接触するが、チェーン法では∀αiは1回だけ接触する。
定理3.1の証明と同じ議論の後、集合平均法の場合​​、

合計時間=mΣi= 1 * Ti = 2×N0 + 2×N1 + ... + 2×Nk + ... + 2×Nm~ O（N0）= O（N）

したがって、設定平均法= O（N）を用いてインクリメンタルセットアップによって取られる時間は、
パラレルセットアップは、各レベルiでの連鎖および集合平均法のクラスタセットアップ時間をλiだけ減少させる。
したがって、定理5.1の証明と同様に、レベルiにおけるすべてのクラスタを設定するための並列セットアップ時間Tiは、

Ti =pΣj= 1 * tj = Ni /λi

### 5.6. Naming of Sensor Nodes
CSNのノードのハッシングでは、ノードが地理的な位置を知る必要はなく、CSNはスケーラブルな方法でノードに一意の名前を割り当てます。
このノードの名前付けには2通りの方法があります。

インクリメンタルネーミング：インクリメンタルネーミングでは、ノードの命名は、クラスタセットアップフェーズでボトムアップ方式で行われます。
現在のクラスタ階層、ρは無作為に初期化された変数、λiはレベルiでのクラスタあたりのノードの最大数、τはクラスタCに含まれるセンサの集合、|τ| τの要素数を与える。
最初は、τ= 0である。
図2および図3に記載されているように、連鎖法または集合平均法の第1 /クラスタヘッドω= min（基地局β）。
この固有のセンサには、[i.ρ.|τ| ]。
一般に、∀αi∈C：αiの名前= [i.ρ.|τ| ]、センサは命名された後に集合τに置かれ、1つのクラスタ形成の完了が別のクラスタ形成の完了をトリガするとき、 ρをインクリメントする。
ノード命名アルゴリズムによって割り当てられるノード名の例は、0.23.5,0.25.2,2.37.0などとすることができる。
特定の名前のアドレス形式の下位レベルの詳細は、このペーパーの範囲を超えています。

パラレル・ネーミング：パラレル・ネーミングは、クラスタ階層が形成された後、最上位層のセンサに命名してから、すべての下位層クラスタのネーミング・プロセスを同時にトリガして開始されます。
インクリメンタル命名アルゴリズムで定義されている用語に加えて、kをクラスタリング階層の現在のレベルを示す変数とする。
パラレル命名アルゴリズムについては、図5を参照してください。
増分命名には、命名フェーズがセットアップフェーズで完了したときにノードに命名する余分なオーバーヘッドはありません。
ただし、パラレル命名には、クラスタのパラレルセットアップが完了した後に開始されるため、オーバーヘッドがあります。
式7と同様に、任意の層iにおける並列命名時間は、Ti = Ni /λiである。

固有の命名がなければ、CSNは正しく機能しません。
したがって、命名アルゴリズムが各ノードにグローバル一意の名前が割り当てられることを保証することが重要です。
A.B.Cをセンサノードの名前形式とする。
命名アルゴリズムから、Cはクラスタ内の各センサに対して一意であり、Bは層内の各クラスタに対して一意であり、Aは各層に対して一意であることになる。
したがって、A.B.Cの組み合わせは、すべてのセンサに対してグローバルにユニークである。

### 5.7. Hashing of Nodes and Keys
ノードの命名が完了すると、これらの名前に基づくノードのハッシングが行われます。
このハッシングはChord [2]のそれと同様ですが、ノードをハッシュするためにIPアドレスを使用する代わりに、セットアップ時にセンサノードに割り当てられた名前を使用します。
鍵のハッシングは、レベルiの各クラスタCでローカルにCSN内で行われる。
CSNのキーのハッシュもChord [2]に似ています。
各ノードは、観測しているデータにローカルで名前を付け、名前付きデータに関連付けられたメタデータキーを生成します。
このメタデータキーをハッシュするとキー識別子が生成され、ノード名をハッシュするとノード識別子が生成されます。
SHA-1 [26]ハッシュ関数を使用して、キーとノードをハッシュします。
キー識別子は、そのキー識別子≤ノード識別子のやり方でノードに割り当てられます。
レベルiの各ノードαi∈クラスタCは、クラスタ内の他のノードのO（logλi）の情報をそのローカルフィンガテーブルに保持する。ここで、λiはレベルiのローカルクラスタ内のノードの数である。
鍵識別子は、ハッシュ関数内のノードのグローバルに一意の名前を含めることによって、グローバルに一意にすることができます。

### 5.8 Lookup Operation
各センサは、αiが最高レベルmに参加し、ユーザの問い合わせを聞くことができると言う。
ユーザは、地理的に最も近いαi∈レベルにクエリを送信する。
Rmodeによれば、照会を受け取ると、センサαi∈レベルmは、照会されたキーがそれ自身のローカル記憶装置に存在するかどうかを最初にチェックする。
そのキーが見つからなければ、αiはローカルフィンガーテーブルをチェックします。
各ノードαiのフィンガーテーブルは、O（logλi）個のノードに関するデータ情報を含む。
フィンガーテーブルにも必要なキーが含まれていない場合、クエリはフィンガーテーブルに従ってターゲットに最も近いノードに送信されます。
αkはそのノードであると言う。
このようなαiで同じ手順を繰り返す。
階層的クラスタリングでは、ノードによって鍵マッピングがレベルi = 0でのαfとなるとき、αfはレベルi-1でそのメンバ・クラスタ内でルックアップ・オペレーションを実行する。
この手順は、レベル0に達するまで繰り返され、この場合、ルックアップ操作の結果は、照会されたキーに関連するデータを実際に格納しているノードを見つける。

### 5.9 Node Failures and Node Joins
CSNは、バックアップノードαbのデータ複製によって個々のノードの障害を処理します。
このようなαbは、他のノードと共に展開することができるが、π0= {ネットワーク内のすべてのノード}には含まれない。
したがって、それらは、階層型クラスタ設定の後ではどのクラスタにも属しません。
各αiは、利用可能なαbを地理的に近くに配置し、それらをデータの複製に使用する。
あるいは、クラスタの他のメンバノード上でデータレプリカを作成することもできる。
Chord [2]と同様に、各センサノードαiはサイズrの後続リストを維持し、αiの後続者が応答していない場合、αiはリストrの次の後続者と連絡をとることができる。
同時に失敗するαiの後続リストR上のすべてのセンサの確率は、R [2]の中程度の値で任意に小さくすることができる。
以下の定理はChordの論文[2]で証明されている。

定理5.5と5.6では、関数find successorはノード[αi]のすぐ後継者を返すChord [2]手続きを指します。
ノードを自発的に離れるノードは、おそらく低エネルギーのために残そうとしているノードαiがリング形成クラスタを離れる前にそのキーをαiの後続ノードに転送しなければならないという制約が追加されたノード障害として扱うことができる。
CSNノードでは、結合は独立して行われません。
ノード参加は、リング形成クラスタに参加するために利用可能なバックアップノードαbが存在し、ノードαiが自発的に失敗する場合にのみ発生する。
ノード結合は、自発的にクラスタを離れるようなαiの場合とは異なり、αiはすべての情報をαbへの後続ポインタとともに通過する。
このようなノード結合は、Chord [2]のノード結合よりもずっと簡単です。
# Simulation and Experimental Results

# Conclusion & Future Work
最近ではより現実的な環境で実験を行っています。
移動性は、プロトコルがノードと通信経路の厳密な配置を必要とするため、CSNに固有の課題を提起する。
モバイルSN環境の一例は、トラフィックを監視するためにタクシーブに配置されたセンサであってもよい。 
モビリティを処理するための1つの方法は、フィンガーテーブルを最新の状態に保つための高速更新方法をCSNに組み込むことです。
CSNでは、レベルi = 0の各ノードは、レベルiのクラスタCのO（logN）メンバノードだけでなく、すべての下位レベルのすべてのメンバノードのフィンガテーブルを格納する必要がある。
これにより、センサノードのストレージ要件が増大し、これらのノードのストレージの制限がスケーラビリティのボトルネックになる可能性があります。 
私たちは、物理センサーの記憶領域を増加させる効率的な方法を模索しています。
現在進行中の他の研究は、LEACH [19]およびPEGASIS [20]とのCSNの比較研究である。

CSNは、無線センサネットワークにおけるデータの効率的な位置特定手段を提供する。
アプリケーションからのクエリが行われない限り、CSNのセンサは低電力モードで動作します。
これにより、特にアプリケーションからの実際のクエリの頻度が低い場合に、SNの存続期間が大幅に長くなります。
CSNのRモードの性能は、EEモードと一般的に比較しても印象的です。
RmodeのCSNは、O（ログN）の境界でデータのルックアップを実行します。 これは、上に実行されているアプリケーションに対して強力な保証を提供します。 最後に、CSNは大規模なSNに拡張されます。
