# Wireless Sensor Network Virtualization: A Survey
Imran Khan, Student Member, IEEE, Fatna Belqasmi, Member, IEEE, Roch Glitho, Senior Member, IEEE,
Noel Crespi, Senior Member, IEEE, Monique Morrow, Senior Member, IEEE, and Paul Polakos

## Abstract

ワイヤレスセンサネットワークは、新たに登場するIOTパラダイムの主要コンポーネントです.
それらは今や色々な場所に偏在しており、複数のアプリケーションドメインで使用されています.

wsnはドメインが固有で、基本的には特定のアプリケーションをサポートするという形態です。
しかし、WSNのノード自体がどんどん性能を上げているため、複数のアプリケーションを同一のWSNで走らせることを研究するのが益々重要になっています。

仮想化技術はこのWSNの共有を可能にする技術です。このサーベイ論文はWSNの仮想化に関する調査です。
 最先端技術の包括的なレビューと研究課題の詳細な議論を提供します。 WSN仮想化の基礎を紹介し、慎重に選択されたシナリオでその動機付けを促します。

既存の作品は、シナリオから派生した一連の要件を使用して詳細に提示され、批判的に評価されます。 関連する研究プロジェクトもレビューされています。 また、いくつかの研究課題についても、
取り組むことができた。

## Introduction

IoT（Internet-of-Things）の概念は、次世代の技術革命であり、多くの種類のデバイス間の通信を実現し、かつてない規模であると考えられている[1]。
	WSNは、IoTの基本的な構成要素と見ることができる。これは、ユーザーが（人間または機械）が自分たちの環境とやり取りし、現実世界の出来事に反応するようにします。
	
これらのWSNは、マイクロエレクトロメカニカルシステム、ワイヤレス通信、デジタルエレクトロニクスの融合であり、環境を感知し、計算を実行し、通信する能力を持つノードで構成されています。
現在のWSNの最も明白な欠点は、ドメイン固有でタスク指向であり、新しいアプリケーションのために再利用する可能性がほとんど、または、全くない特定のアプリケーションに適していることです。
この考えは非常に非効率的であり、新しいアプリケーションを検討するとき、面倒臭いです

IOTの促進において複数のアプリケーションを同時に動かすことは必須になりつつあります。

仮想化は、実際の物理コンピューティングリソースを論理単位に抽象化し、複数の独立したユーザーによる効率的な使用を可能にする、確立された概念です[3]。
これは、複数のアプリケーションが同じ仮想化されたWSN上に共存できるため、WSNの展開を効率的に利用できる有望な手法です.

```plain
memo: このwsnの仮想化っていうのはノードの上のOSに仮想化プロセスを複数走らせる事なのか、それともwsn自体をなんかのシミューレータで仮想化しているのかどっち？？？？
```

2番目の関連する利点は、WSNサービスアプリケーションとWSNの展開の間の緊密な結合を排除することです。
これにより、経験豊富な初心者のアプリケーション開発者は、関連するWSNの技術的詳細を知る必要なく、革新的なWSNアプリケーションを開発することができます。
ま、要はアプリ開発だけに専念できる。

```plain
memo: ただどんだけ気にしなくていいのかはわからず。つーかまずwsnのアプリケーションの実例がよくわからん
```

もう1つのメリットは、WSNのアプリケーションとサービスは、サードパーティのアプリケーションを相互利用することができることです。
また、物理WSNプロバイダ、仮想WSNプロバイダ、WSNサービスプロバイダなどのロールを使用してビジネスモデルを定義することもできます。

WSN仮想化の概念は、いくつかの興味深いアプリケーション分野に適用できます。
近年のスマートフォンや自律型車両の進歩により、オンボードセンサーを複数搭載することが可能になりました.
```
memo: え、興味深いアプリケーション分野については？？　スマホ？自動車系なの？
```

えば、都市の都市におけるCO2濃度を監視するために何千ものセンサが必要とされる、日和見的な都市検知のシナリオが提示されている[7]。
WSN仮想化は、これらのセンサーを導入し管理する代わりに、市民のセンサーを利用して必要なデータを提供するための重要な技術として使用できます。 同様に、Sensing-as-a-Service（SaaS）モデルは[8]にいくつかのユースケースシナリオとともに提示されています。

WSN仮想化は、配備されたセンサーの費用対効果の高い活用を通じてSaaSモデルを実現するのに役立ちます。 他のいくつかの動機付けの例が[9]と[10]にあります。

もちろん、そのような利用が行われる前に解決すべき多くの技術課題がありますが、この分野で革新的なソリューションを提案するために、より深くて完全な探索空間探査の強い動機付けも提供します

多くの研究者はWSN仮想化をキーとなる技術として考え、そのモチベーションを提供しています。 WSN仮想化は、[11]の著者によると、IoTのコンテキスト(文脈)での情報共有のための強力なイネーブラ(補助者)であり、データ分析技術とともに使用されています。
	
スマートシティ環境は、[12]で検討されています.WSN仮想化は、展開されたインフラストラクチャを効率的に利用するために使用できます

```
memo: スマートシティ環境ってなんだ・・・
```

このタイプの使用率を達成するには、使用状況に応じて、複数の同時実行モデルを使用することをお勧めします。

[13]では、WSN仮想化のいくつかの側面を捕捉する協調モデルを使用して、WSN仮想化をリソースの効率性を促進する主要なイネーブラとして説明しています
[14]において、WSN仮想化は、ネットワークリソースの効率的な使用を満たすために使用される大規模センサプラットフォームを作成するための重要な技術として構想されています。

無線ネットワークの仮想化をカバーする調査（例えば、[15]）がありますが、WSN仮想化の詳細に焦点を当てていません。 これはキーとなる可能性のある技術ですが、これまでにWSN仮想化（例：
参考文献[16]、参考文献[17]）にはいくつかの制限があります。
現実世界の動機付けシナリオは含まれておらず、最新の動向をレビューしていないため日付も付けられています。 さらに、レビューされる内容とレビューされる内容に関して包括性が欠けています。

例えば、最先端技術の批判的分析のための明確な尺度は存在しない。 さらに、彼らは研究の方向性については、潜在的な解決策について詳しくは触れていません。
本稿は、ワイヤレスセンサネットワークの仮想化に関する調査である。 これまでのところほとんどのアンケート調査の欠点に対処することを目的としています。 その観点から、次のような貢献をしています。

* WSN仮想化の現実的な動機付けシナリオ
* この分野の最新の動向を含め、最先端の包括的かつ詳細なレビュー。
* 動機づけのシナリオから導き出された、よく定義されたヤードスティック(尺度)を使用した最先端技術の重要な分析。
* 未解決の問題の概要と解決方法に関する洞察

セクションIIでは、WSN仮想化の概念とそのタイプの基礎について説明します。
セクションIIIでは、動機付けのシナリオを最初に提示し、一連の要件を提供します。
これらの要件に基づいて、我々は第IV章の最先端技術を批判的にレビューする。
関連するWSN仮想化プロジェクトについては、セクションVで説明します。
セクションVIはいくつかの研究の方向性を概説し、セクションVIIは論文を結論づける。

## 2: WSN仮想化技術の基礎

WSN仮想化は、ノードレベルの仮想化とネットワークレベルの仮想化の2つのカテゴリに大別できます。 このセクションでは、これらの両方のカテゴリについて説明します。

* A:ノードレベルの仮想化
	WSNノードレベルの仮想化により、複数のアプリケーションが1つのセンサノード[18]で同時にタスクを実行できるため、センサノードは基本的に多目的デバイスになります。
	ノードレベルの仮想化の基本的な概念を図1に示します。
	```
	memo: 図１はセンサーノードにOSが乗り、その上に仮想マシン、スレッドマネージャー、ハイパーバイザーのどれか？もしくは全部が動いてアプリを並列に管理しているっぽい
	```
	ノードレベルの仮想化を達成するには、逐次実行と同時実行の2つの方法があります。
	
	シーケンシャル実行は、アプリケーションタスクの実際の実行が1つずつ（直列に）発生する弱い形式の仮想化と呼ばれます。
	このアプローチの利点は簡単な実装ですが、アプリケーションがキュー内で待機する必要があるという明らかな欠点があります。
	同時実行では、あるタスクから別のタスクにコンテキストを迅速に切り替えることによって、アプリケーション・タスクがタイムスライス方式で実行されます.
	このアプローチの利点は、実行時間の短いアプリケーション・タスクは、実行時間の長いアプリケーション・タスクによってブロックされず、複雑な実装が欠点であるということです。
	
* B:ネットワークレベルの仮想化
	仮想センサーネットワーク（VSN）を可能にするのはWSNネットワークレベルの仮想化です。
	VANは、ある時点で1つのアプリケーション専用のWSNノードのサブセットによって形成されます[19]。
	残りのノードは、（たとえWSNが展開したときに想定されていないアプリケーションのために）異なる複数のアプリケーションのために利用可能であるので、このようなサブセットの動的な生成を有効にすると、必ずではないが、同時に、リソースの効率性を確保することができます。

	WSNネットワークレベルの仮想化は、2つの異なる方法で実現できます。
	1つの方法は、図2（a）に示すように、同じ基礎となるWSNインフラストラクチャ上に複数のVSNを作成することです。
	VSNの一部ではないWSNノードは、ルーティングなどの他のアプリケーションやネットワーク機能で使用できます。 2番目の方法は、図2（b）に示すように、VSNが3つの異なる管理ドメインのWSNノードで構成されている場合です。
	
## 3. WSN仮想化ー動機シナリオと要件
	
このセクションでは、最初に文献から得られた2つのシナリオを提示し、一連の要件を考え出します。
これらの要件を使用して、既存の作業を批評的にレビューし、ノードレベルの仮想化、ネットワークレベルの仮想化、およびハイブリッドソリューションの3つのタイプでの作業の集約をグループ化します。

```
memo: ハイブリットソリューションって何？
```

* A: 動機シナリオ
	ここで説明するシナリオは、共通のWSN展開でWSN仮想化を使用する動機付けと利点を示しています
	
	*1）火災監視のシナリオ：ブラシ火災が一般的である地域の近くの都市の例を考えてみよう[9]。
	市政は、火災の早期発見に関心があり、その過程で、火災のカーブ、形、方向を決定するために、WSNと火災輪郭アルゴリズムを使用していると仮定します。
	1つのアプローチは、街の管理者が街全体（すなわち、各通りや個人の家）にWSNノードを配置することができるということですが、火災を検出するためにWSNノードを既に配備している人もいるので効率的ではありません。
	より効率的なアプローチは、WSNノードをその管轄下のエリア（ストリートやパーク）に展開し、既に個人用の家庭に配備されているWSNノードを再利用することです.
	このシナリオでは、2つの異なるアプリケーションが同じWSNインフラストラクチャを共有します。
	1つは住宅所有者に属し、個々の住宅に配備されたプライベートWSNに限定され、もう1つは市政に属し、市政によって配備されたWSNノードとプライベートWSNノードを共有します。
	都市管理アプリケーションは、適応サンプリングのためにすべてのWSNノードに完全にアクセスする必要があるため、定期的な通知またはクエリベースのモデルは適切ではありません。
	
	別の問題は、分散した形で火花輪郭アルゴリズムを実行するために、WSNノードは、火災通知メッセージを互いに交換する必要があることである。
	クエリーベースのデータ交換アプローチは、それぞれのプライベートドメインに位置する2つのWSNノードがデータを直接交換できないため、遠隔の集中化された場所で火花輪郭アルゴリズムの実行を強制するので効率的ではない。
	オーバレイネットワークが可能な解決策の1つです。
	このシナリオは、2人の異なるユーザが共通のリソース、すなわちWSNノードを共有する必要があるため、WSN仮想化の必要性を示している。

	*2) ヘリテージビルディングモニタリング：現実世界のWSNの配置は[20]に示されています。ここでWSNはイタリアの古代の塔の下に道路トンネルを建設することの影響を監視するために使用されます。
	タワーが建設中に自立して崩壊する能力を失う恐れがあったためです。
	今、タワーの運命に興味を持っている3人のユーザーがいると考えてください。
	最初は建設会社です。タワーが自立する能力を失わないようにする必要があります。それ以外の場合、重い罰金を払わなければなりません。
	第2のユーザは、都市周辺のすべての古代遺跡を日常的に監視する保護庁であり、第3のユーザは、建設中に塔が落ちた場合の緊急修復/救助措置を計画しなければならない地方自治体である.
	保全委員会が既にこの塔を含む古代遺跡の健康状態を監視するために独自のWSNを展開している可能性は十分にある。
	この場合、建設会社および地方自治体は、建設期間中に既存のセンサノードを使用することができる。
	WSN仮想化が存在しない場合、可能なソリューションは2つのみです。
	1つは、保全委員会の申請書によって提供される情報に頼ることである。 ただし、この情報は必要な粒度レベルではない可能性があります。
	さらに、保全委員会の申請が設計され、実施されたときに、建設会社および地方自治体の要件が考慮されていないため、必要な情報の一部を入手できない可能性があります。
	2番目の解決方法は、各ユーザーが冗長なWSNノードを展開することです。	
	ここでは、WSN仮想化は、各ユーザーの要件を満たすことで中心的な役割を果たすことができます。

* B: 要件
	このセクションでは、上記のシナリオに基づいて8つの要件のリストを示します。
	表IVでは、既存のソリューションが当社の特定された要件をどの程度満たしているかを示しています。
	第1の要件は、ノードレベルの仮想化の可用性です。
	これは、センサノードが複数のアプリケーションの同時実行をサポートできることを保証する基本的な要件です。
	
	第2の要件は、センサノードが動的にグループを形成して、各グループが異なるアプリケーションに属するように複数のアプリケーションタスクを分離して透過的に実行する能力に関するネットワークレベルの仮想化です。
	
 	3番目の要件は、アプリケーション/サービスの優先順位のサポートです。
	ほとんどのWSNは、セキュリティ、火災監視、戦場の状況やサーベイランスなどのミッションクリティカルな状況のために配備されています。 このような状況では、ミッションクリティカルなアプリケーション/サービスは、実行メカニズムの優先順位付けを行う必要があります。
		
	第4の要件は、どのWSN仮想化ソリューションもプラットフォームに依存しないことで、特定のハードウェアまたはソフトウェアプラットフォームに依存しないことです。
	
	第5の要件は、提案されたソリューションが、近隣探索とサービス発見の両方のためのリソース発見メカニズムを有するべきであるということである
	
	第6の要件は、提案された解決策が、初期世代センサノードを含むリソース制約型センサノードへの適用可能性に基づいている。

	レガシーセンサーノードをWSN仮想化ソリューションの一部にするメカニズムも、この要件の対象となります。

	第7の要件は異種性であり、これは、ソリューションが異なる能力（例えば、処理能力、メモリ）を有する様々なWSNプラットフォームに適用可能でなければならないことを意味する。
	これらのプラットフォームには、MICAZ、MICA2、Atmel AVRファミリ、MPS430などが含まれます。

	8つの要件は、アプリケーションタスクのためのセンサーノードを選択する能力です。 複数のアプリケーションが同時に展開されたWSNを利用する場合、アプリケーションには空間的および時間的要件があるため、適切なセンサノードの選択は非常に重要です[21]。

## 4. 最先端

このセクションでは、最先端技術を提示し、それを批判的に分析します。

既存の作業を、ノードレベルの仮想化、ネットワークレベルの仮想化、およびハイブリッドソリューションとして分類します。
ハイブリッドソリューションは、ノードレベルとネットワークレベルの両方の仮想化を統合します。
各カテゴリーは、使用されたアプローチに基づいてさらに分類される。

### A. ノードレベルの仮想化
	ノードレベルの仮想化アプローチは、センサ・オペレーティング・システム（OS）ベースのソリューションと仮想マシン/ミドルウェア（VM / M）ベースのソリューションという2つの傘の下にまとめられています。
	センサOSベースのソリューションでは、ノードレベルの仮想化はセンサOSの一部です。 VM / Mベースのソリューションでは、ノードレベルの仮想化はセンサーのOS上で実行されるコンポーネントによって実行されます。

	```
	memo: vm/m solutionって何だろう・・・
	```

	ノードレベルの仮想化ソリューションは、2種類のプログラミングモデルを使用します。 イベントドリブンとスレッドベースです。
	イベント駆動型プログラミングモデルはセンサーに実装するのが簡単です。
	イベント駆動型プログラムは、温度値が閾値を上回るなど、イベントをリッスンするメインループを有する。
	イベントが発生すると、イベントハンドラを使用してイベントを処理するコールバック関数が呼び出されます
	プログラムがI / Oイベントによってブロックされると、そのイベントハンドラは単にコンテキスト切り替えを伴わずにコントロールを返します.

	限られたリソースと共通のアドレス空間の使用のために、スレッドベースのモデルはセンサーに実装するのが難しいです。(今のデバイスだったら大丈夫じゃね？田辺先輩も実装してるし)
	各プログラムは複数のスレッドから構成され、スレッドがブロックされると、他のスレッドを実行するためにコンテキスト切り替えが必要となる[22]。

	図3はノードレベルの仮想化タイプを示し、表1はノードレベルの仮想化に対処する既存のワークの特性を示す。
	```
	memo: 図３は各OS(contiki tinyos )の上でアプリがどのように走るかの図 
		  表１はOSによってのプログラミングモデル、言語、OS間とアプリケーション間での資源の共有について、通信プロトコルのサポート範囲、リアルタイムアプリケーションのサポートの有無等が書かれている
	```	

<!-- ***********************************************************************************************************************  -->


	* こっから表１にある各OSの説明！！！（くっそ長い！）
	
	* SenSmart概要
	1）
	センサーオペレーティングシステムベースのソリューション：SenSmart [23]は、非常にリソースが制約されたセンサーノードでの同時アプリケーションタスクの実行をサポートする最近のマルチタスクセンサーOSです。
	これは、並行アプリケーションタスクの実行に関連する問題に取り組むように設計されています。
	通常、アプリケーションタスクにはあらかじめ定義されたスタックスペースが関連付けられていますが、スタック割り当ては実行時に動的に管理されます。
	最初に、各アプリケーションタスクはデフォルト（スタック）メモリ領域とタイムスライスを取得しますが、実行中にSenSmartは割り当てられたスタックのサイズと場所を明示的に管理します。
	各アプリケーションタスクは、実行時に論理アドレスを使用し、OSによって管理され、物理メモリにマッピングされます。 スタックスペースは、もはやそれを必要としないタスクから再利用することができます。
	新しいタスクの実行がスケジュールされると、現在のタスクのコンテキストが圧縮され、再開のために循環バッファに保存されます。

	システムアーキテクチャは、コードをコンパイルし、それをリンクし、最終的にそれをセンサノードに分配する基地局からなる。
	ネットワーク層サポート（6LoWPAN）または任意の無線プロトコルのサポートに関する記述はありません。

	ノードレベル仮想化のサポートは、複数のアプリケーション・タスク・コードをコンパイルして1つのコード・イメージにリンクすることによって提供されます。
	アプリケーションタスクコードはnesCでプログラムされ、各タスクのコンパイルされたバイナリコードはリライタによって変更され、他のバイナリコードと組み合わされ、最後にプリコンパイルされたカーネルランタイムとリンクされます.
	カーネル・ランタイムは、インスタンス化されたときにアプリケーション・タスクがマルチタスク・セマンティクス（スタック管理、コンテキスト切り替え）に従い、同時に実行されることを保証します。 
	最終的な実行可能コードが生成されると、それは任意の無線再プログラミング手法を使用してセンサノードに伝播することができる。 
	すべてのバイナリコードを最初にコンパイルしてリンクするという戦略は、OSとアプリケーションのタスクが分離されていないことを意味し、新しいアプリケーションタスクが検討されるときはいつでも、センサノードのソフトウェアはすべて更新されます。 
	OSはイベントドリブンプログラミングモデルを使用し、感覚・送信ワークフローモデル[24]に従います。
	
	SenSmartは、Mica2 / MicaZハードウェアプラットフォームで実装され、同時タスクが実行される場合の共通システム機能、アプリケーションベンチマーク、およびタスクスケジューラのパフォーマンスのオーバーヘッドを評価しました。
	一般的なシステム機能のオーバヘッドは、特にコンテキストの保存、復元、切り替えなどの重要な機能に対して許容範囲内です。
	
	これらのすべての機能は127μs〜316μsの間になります。 
	アプリケーションのベンチマークのために、同じアプリケーションがTinyOSよりもSenSmartでより多くのCPUサイクルを使用することが判明しました。 
	並行タスクの場合、複数のタスクの実行中に記録された遅延はコンテキスト切り替えと同じオーダーの大きさであることが評価されました。

	* RIOT概要
	RIOT [25]は、IoTのさまざまなハードウェアに柔軟なOSを設計する際の課題に対処する最新の試みです。 
	RIOTの概念は、従来のまたはリソース制約のある既存のOSのどれも、IoTのさまざまなハードウェアリソースをサポートできないという事実に基づいています.

	RIOTの焦点は、リアルタイムマルチスレッドサポート、開発者に優しいプログラミングモデル、C / C ++に基づくPOSIXライクなAPI、6LoWPANとRPLを使用したリソース制約のあるデバイスに対するフルTCP / IPネットワークスタックサポートなどの機能を提供することです

	RIOTはマイクロカーネルのアーキテクチャに基づいており、基本的なアプリケーションには1.5 kBのRAMと5 kBのROMしか必要としません。
	RIOTは8ビット、16ビット、32ビットの全プロセッサで動作するため、IoTのパラダイムの多様なハードウェアデバイスに特有のオペレーティングシステムになる可能性があります。
	この適応性は、ハードウェア抽象化レイヤーを使用して実現されます。

	全体として、RIOTはモジュラーアプローチを採用し、システムサービスとユーザーアプリケーションのタスクはスレッドとして実行されます。
	スケジューラは、スレッド間のコンテキスト切り替えを最小限に抑えるように設計されています。
	数クロックサイクル。 カーネルはFireKernel [26]に基づいており、最大限の信頼性とリアルタイムマルチスレッディングを提供します。
	システムタスクには静的メモリ割り当てがありますが、アプリケーションスレッドでは動的メモリ管理が使用されます。
	RIOTは進行中の作業であり、これまでのところパフォーマンスの結果や既存のOSとの比較はありませんが、コードはWebサイトで入手できます。

	WSN仮想化の状況では、RIOTはリアルタイムのスレッドベースのプログラミングモデルを使用し、さまざまなシステムサービスとアプリケーションタスクが標準のANSI C / C ++でコーディングされ、並列に実行されます。
	スレッドは優先順位に基づいて優先使用できます。
	アプリケーションタスクは、ハードウェアとソフトウェアとは独立してコーディングされているため、異なるデバイス上で実行することができます。 
	スマートシティなどの大規模な展開では、センサノードおよび他のIoTデバイス（例えば、監視カメラ）を便利にプログラムすることができる。
	
	これまでのところ、RIOT OSに関する性能結果は存在しないが[27]の著者は定性的または量的比較なしに既存の競争に対するアプローチの理論的比較を提示する

	* SenSpire
	SenSpire OS [28]は、イベントドリブンとスレッドベースの両方のプログラミングモデルをサポートするもう一つの最近の取り組みです。
	
	彼らの仕事には4つの主な特徴があります。
	センサノードは制御メッセージに応答します。可用性 - ノードは必要に応じてデータ転送に利用可能なままです。プログラミングモード - ハイブリッドで効率性 - 非常にリソースが制約されたセンサノードでOSを使用できるようにする

	SenSpireのもうひとつの貢献は、ネットワークアプリケーションを開発するための多層（無線、リソース、センサーネット）の抽象化です。
	無線レイヤーは、異なるMACプロトコルを使用してデバイスドライバーを書き込むことを可能にします。
	リソース層は、下位層を公開し、異なるアプリケーション・タスクがそれを同時に使用することを可能にする。

	新しいオブジェクト指向言語（CSpire）が、ハイブリッドプログラミングモデルを使用してユーザアプリケーションタスクをプログラムするために提供される。
	SenSpireは静的最適化を使用します。つまり、アプリケーションタスク、状態、およびカーネル構造を事前に知っておく必要があります。 これにより、WSNの実際の展開の要件である柔軟性が制限されます。

	SenSpireのカーネルはC言語で記述され、アプリケーションタスクはCSpireで記述されています。 この論文では、Mica2、MicaZ、およびTelosBノードでのSenSpireの実装に基づく広範な結果について説明します。
	さまざまなベンチマークでの性能は、MANTIS [29]およびTinyOS [30]の性能と比較されます。 全体的な調査結果によると、SenSpireはこれらのOSに匹敵するパフォーマンスを提供しています。

	WSN仮想化では、SenSpireはイベント駆動型とスレッドベースのプログラミングモデルの両方を組み込んでいます。
	タスクは、イベントまたはスレッドとしてプログラムすることができます。 イベントタスクはスレッドタスクよりも優先度が高い。
	システムタスクは、予測可能で維持しやすいため、通常はイベントタスクとして実装されます。
	アプリケーションタスクは、さまざまな優先順位のスレッドタスクとして移植されます。
	優先度の高いスレッドタスクまたはスリープ状態になると、スレッドタスクが優先されます。 この設定は、スレッド・タスクがタイムスライス方式で実行される他のOSとは異なります
	SenSpireでは、より優先度の高いスレッドによって優先されない限り、スレッドはrunto-completionモデルに従います。
	スレッドの実行は、優先順位が同じ場合は順次実行されます（先入れ先出し）。 
	CSpire言語を使用してアプリケーションタスクをプログラミングすることは、開発者の学習曲線を意味します。

	階層化アプローチを使用しているにもかかわらず、アプリケーションタスクはOSと密接に統合されているため、新しいアプリケーションタスクが検討されると、すべてのセンサノードソフトウェアが更新されます。
	SenSpire OSのパフォーマンス結果は、割り込みレイテンシがTinyOSよりも小さいことを示しています。
	タスクスケジューリングのオーバヘッドは、SenSpireの場合より多くの遅延を示すMANTIS OS [29]と比較されます。
	ラジオやCPUを含むさまざまなタスクのエネルギー消費は、TinyOSとほぼ同じです。

	* MANTIS
	MANTIS [29]は、センサノード上での同時実行をサポートするスレッドベースの組み込みオペレーティングシステムである。
	OSのカーネルとスレッドはC言語でプログラミングされ、さまざまなハードウェアプラットフォーム間で移植可能です。

	システムレベルのスレッドとユーザーレベルのスレッドがあります。 
	OSカーネル、スケジューラ、およびその基礎となるハードウェアは、ユーザレベルのスレッドのAPIとして公開されています。

	MANTISは、優先順位をスレッドに割り当てることによってプリエンプティブマルチスレッドをサポートし、タスクのインターリーブと遅延の回避を可能にします。 
	長期実行スレッドは、短期実行スレッドによって優先使用できます。
	これらのスレッドの同時実行はコンテキスト切り替えによって実現されます。
	スレッドの実行が中断されると、その現在の状態はすべてそれ自身のスタックに格納され、後で検索されて実行を再開します

	すべてのスレッドは、カーネルによって管理されるスレッドテーブルにエントリを持っています。
	そのサイズは固定されているので、あらかじめ定義された数のユーザーレベルのスレッドしか作成できません。

	MANTIS OSのその他の主な機能には、動的再プログラミングメカニズムがあります。
	展開されたセンサーノード、リモートデバッグメカニズム、およびx86ベースのプロトタイププラットフォームです。
	動的再プログラミングのオプションは、OS全体のワイヤレス再点滅、単一スレッドの再プログラミング、およびスレッドの変数の変更です。
	OSのワイヤレス再点滅とシングルスレッドの再プログラミングは、進行中の作業として言及されています。
	コマンド・サーバーは、リモート・デバッグに使用されます。 センサノードは、コマンドサーバのクライアント部分を実行する。

	どのユーザもセンサノードにログインして設定を変更したり、スレッドを実行または停止したり、再起動したりすることができます。
	著者らは、AESおよびRC5暗号化アルゴリズム、算術コードを使用する圧縮/復元アルゴリズム、および64ビットFFTアルゴリズムを含む、MICA2ノード上のMANTISでいくつかの厳しいタスクを実装しました。
	これらのタスクは、MANTISで実行時間が短縮されました。 通常、スレッドの同時実行は、コンテキスト切り替えのオーバーヘッドと追加のスタック領域の必要性をもたらします。
	MANTISでは、コンテクストの切り替えがパフォーマンスの低下を招くことはありませんが、スタック推定ツールが役立つことが判明しました。
	
	MANTISは、ノードレベルの仮想化のための興味深いオプションです。スタック/メモリの低レベルの詳細を管理することなく完全にスレッドベースでプログラムが簡単であるためです
	タイムスライスされたマルチスレッドアプローチは、実行完了モデル(run-to-completion)を使用せずにアプリケーションタスクを同時に実行することを可能にします。

	アプリケーションスレッドはC言語で記述されており、OSとは独立しています。 MANTISは動的再プログラミングをサポートしていますが、このペーパーでは完全に説明されていません。
	現在のところ、プロジェクトページ[31]がかなり古い情報を持っているため、MANTISの作業が進行中であるかどうかは明確ではありません。
	[29]で提示された性能結果は非常に限られている。
	競合他社のソリューションとの比較はありません。 MICA-2プラットフォームを使用したいくつかの複雑なタスク（圧縮/解凍とRC5とAES暗号化）と消費電力の実行時間を紹介します。

	```
	memo: どこで紹介してんだ！論文の後ろの方か？とりあえず次から別のOSの紹介
	```

	* LiteOS
	LiteOS [32]は、センサノード用に設計されたUnixライクなOSです。 
	階層ファイルシステム、ワイヤレスで動作するコマンドシェル、マルチスレッドアプリケーションの動的実行、デバッグサポート、ソフトウェア更新などの豊富な機能を提供します。 
	LiteOSは、WSNをUNIX風のファイルシステムとしてマッピングします。このシステムでは、ユーザが使い慣れたUNIX風の方法で異なるコマンドを実行できます。
	i）LiteShell、ii）LiteFS、およびiii）カーネルの3つのコンポーネントがあります。 
	LiteShellは、基地局に常駐するコマンドシェルであり、センサノードと通信してファイル、プロセス、デバッグ、環境、デバイス関連のコマンドを実行するために使用されます。 
	ワイヤレス範囲内では、USBがコンピュータに接続されているのと同様に、センサノードをLiteShellでマウントすることができます。 
	しかし、このプロセスは、インターネットまたはマルチホップ通信では達成できません。
	センサノードはLiteShellに関する状態を維持せず、単にコマンドに応答します。

	LiteFSは、RAM、EEPROM、およびフラッシュメモリをそれぞれ使用する3つのモジュールに分割された階層ファイルシステムです。
	RAMは開いているファイルを保持し、割り当て情報とデータ情報はそれぞれEEPROMとフラッシュメモリに格納されています。 
	EEPROMは階層ディレクトリ情報を保持し、実際のデータはフラッシュメモリに格納されます。 
	LiteOSプログラミングモデルは、イベントベースとスレッドベースの両方のアプローチをサポートしています。
	スケジューリングメカニズムはハイブリッドでもあり、優先度ベースおよびラウンドロビンベースのスケジューリングをサポートします。
	ユーザーアプリケーションはマルチスレッドベースであり、スレッド間でメモリ共有がないため、同時スレッドにはメモリ競合がありません	
	全体として、LiteOSのアーキテクチャはUNIXに触発され、分散して動作します。 
	LiteOSアプリケーションはマルチスレッド化されているのに対し、TinyOSアプリケーションはシングルスレッド化されているため、LiteOSアプリケーションのメモリ消費量はTinyOSよりも大きい。
	
	LiteOSは、ノードレベルの仮想化を実装するための柔軟なアプローチを提供します。
	これは、アプリケーションスレッドの同時実行を可能にし、コールバックメカニズムを通じてイベントを処理するハイブリッドプログラミングモデルハイブリッドを使用します。 
	アプリケーションタスクはC言語でプログラミングできます。 アプリケーションタスクのインストールと実行は非常に簡単で、ユーザーアプリケーションを動的にコピーすることで実現できます。 
	LiteOSのもう1つの利点は、コールゲートによるアプリケーションとOSの分離です。
	コールゲートはポインターであり、システムソフトウェアとリソースにアクセスするためのアプリケーションアクセスポイントとして機能します。 
	つまり、センサーノードをゼロから再プログラミングすることなく、新しいアプリケーションをセンサノードに簡単にロードすることができます。

	LiteShellのパフォーマンス結果は、LiteShellを使用して送信されたコマンドの平均応答時間を示します。 
	一般的なネットワークコマンドの平均遅延は500ミリ秒未満です。 
	コピーコマンドを使用してネットワークでファイルを送信する遅延は、ファイルサイズによって異なります。 
	4 KBのファイルコピーの遅延は、それぞれシングルホップと2ホップ転送で約3秒〜7.5秒です。 
	ソースコードの長さはTinyOSと比較され、LiteOSではTinyOSより数行しか書かれていないが、マルチスレッド対応であるためLiteOSアプリケーションはTinyOSよりも多くのメモリを占有していることがわかります。

	* PAVENET OS
	PAVENET [33] OSは、マルチスレッドアプリケーションタスクの優先権に関する問題を排他的に処理するように設計されたスレッドベースのOSです。
	しかし、PAVENETには1つの大きな欠点があります。それは非移植性です。 
	PIC18マイクロチップだけで動作し、他のセンサーOSとは異なり、MICAZなどの他のハードウェアプラットフォームでは使用できません。
	優先と協調型の2種類のマルチスレッドが用意されています。
	前者は、リアルタイムタスク（例えば、無線アクセス、センササンプリング）に使用され、後者は、ベストエフォートタスク（例えば、ルーティング）のために使用される。 
	PAVENETは、プリエンプションオーバーヘッドとスタック/メモリスペース管理の問題に対処する3つの貢献をしています。
	リアルタイムタスクスケジューラ、ベストエフォート型タスクスケジューラ、および下位レイヤを抽象化する無線通信スタックを提供します。
	スイッチングオーバヘッドの影響を軽減するために、PIC18チップの機能はリアルタイムタスクスケジューラに使用されます。
	関数の1つは、タスクのコンテキストを自動的に保存する高速リターンスタックです。
	ベストエフォート型タスクスケジューラは、スタック型/メモリ型の問題を回避するために協調型タスクスイッチングを利用します。
	無線通信スタックは、物理層とアプリケーション層との間にMAC層、ネットワーク層、およびソケット層を含む。バッファは、データフローを処理するためにMACレイヤ、ネットワークレイヤ、およびソケットレイヤによって共有されます。
	等しい優先順位を持つタスクはグループ化され、単一のタスクとして実行され、TinyOSのコードサイズよりも小さいコードサイズになります。
	アプリケーションを実行するのに必要な平均クロックサイクルは、TinyOSに必要なものよりも優れています。
	マルチスレッドのサポートは、複雑なタスクの場合、PAVENETがTinyOSよりも多くのRAMとROMを使用することを意味します。	

	WSN仮想化の場合、PAVENETはスレッドベースのプログラミングモデルを提供し、C言語を使用します。
	さまざまな優先順位レベルでマルチスレッドアプリケーションをプログラミングすることは可能ですが、タイムスライス実行が提供されていないため、それらの実行は順次であり、同時ではありません。 
	また、OSからのアプリケーションタスクの分離もありません。 
	PAVENETの主な欠点は、ポータビリティの欠如ですが、より良いハードウェア設計がどのように効率的なセンサーOSにつながるかを示す面白いアプローチです。

	PAVENETのパフォーマンス結果は、サンプルアプリケーションでTinyOSより多くのRAMを使用していることを示しています。
	サンプルアプリケーションの実行時間はTinyOSに匹敵します。 タスク切り替えのオーバヘッドは、MANTISより5倍少なく、TinyOSに匹敵します。 
	もう1つの側面は、PAVENETとTinyOSのサンプルアプリケーションをコーディングするために必要なコード行の比較です。 
	PAVENETは、TinyOSの2倍の量を使用します（複雑なアプリケーションの場合はさらに多くなります）。

	
	* Contiki OS
	Contiki [34]は、WSNの中で最も一般的なシステムの一つであり、長年に渡って、IoTと低消費電力の組み込みネットワークシステムの主要なプラットフォームに成長しました。 
	イベントドリブンモデルに基づいたカーネルを備えていますが、プリエンプティブなマルチスレッドもオプションとしてライブラリの形で提供され、アプリケーションが必要な機能を呼び出すためのAPIとして公開されています。 
	プリエンプションはタイマ割り込みを使用して実装されます。 すべてのスレッドには独自の実行スタックがあります。

	protothreads [35]の概念は、イベント駆動とスレッドベースのアプローチのコンセプトを組み合わせるために導入されました。 
	Protothreadsはスレッドのブロックウェイトアプローチを借用し、スタックレスのアプローチで実装しています。 
	protothreadsの利点は、スタックの要件が従来のスレッドよりも低く、イベントとは異なり、プリエンプトできることです。 
	Contikiを使用すると、センサノード上でアプリケーションやサービスをワイヤレスで動的にアップロード/アンロードすることができます。 
	これは、アプリケーションバイナリに再配置情報を組み込み、後で実行時再配置を実行することで可能になります。

	OSはC言語で書かれており、多くのハードウェアプラットフォームに移植することができます。 
	CPU多重化とイベント処理メカニズムは、カーネルによって提供される2つの主要な機能です。
	残りのシステム関連機能は、必要に応じてアプリケーションが使用できるシステムライブラリとして提供されます。
	ハードウェア抽象化レイヤはなく、アプリケーションは基盤となるハードウェアを直接利用できます。 
	OSはイベントドリブンであるため、イベントハンドラが呼び出されると、割り込みによってプリエンプトすることができます。
	それ以外の場合は、完了するまで実行する必要があります。
	単純な無線プロトコルは、WSN内のアプリケーションを動的にロード/アンロードするために使用されます。
	新しいアプリケーションコードのバイナリイメージは、ポイントツーポイント通信を使用して選択されたネットワークノードに送信されます。
	残りのセンサノードは、それらからブロードキャストされたアプリケーションコードを受信する。 
	Contikiの現在のバージョンにはIPv6 [37]、CoAP [38]、RPL、6LowPAN、Cooja、実際の展開前にエミュレートされたデバイス上のアプリケーションをテストするネットワークシミュレータ、Coffeeフラッシュファイル外部フラッシュメモリを持つセンサー用のシステム[39]、およびアプリケーションをデバッグするためのコマンドラインシェルです。
	実際の展開前にエミュレートされたデバイス上のアプリケーションをテストするためのシミュレータ、外部フラッシュメモリを持つセンサ用のCoffeeフラッシュファイルシステム[39]、アプリケーションをデバッグするためのコマンドラインシェルなどがあります。

	ノードレベルの仮想化では、Contikiは利用可能なより良い選択肢の1つです。 
	これは、OSに依存せず、その上で動作する複数のアプリケーションをサポートします。 
	アプリケーションは、C言語でプログラミングし、OS全体を再インストールすることなく更新/インストールすることができます。 
	これは、ハイブリッドプログラミングモデルを提供する。 
	protothreadを使用すると、共通のスタックを共有するマルチスレッドアプリケーションを効率的に作成することができます。 
	Contikisはさまざまなハードウェアプラットフォームをサポートしています。

	この作品で使用された元のContiki紙は、すべての体系的なパフォーマンス結果を提供していません。 
	しかし、パフォーマンスに関するいくつかの洞察が提示されました。 
	たとえば、新しいコード（6 KBサイズ）でセンサノードを再プログラミングするのにかかる時間は30秒ですが、同じコードで40ノードを再プログラミングするのに30分かかりました。 
	Contikiの類似アプリケーションのコードサイズは、TinyOSよりも大きいがMANTISよりも小さいことがわかります。

	* TinyOS
	TinyOS [30]は、センサーノードにOSソリューションを提供するための注目すべき取り組みの1つです。
	これは、イベント中心であり、革新のための柔軟なプラットフォームを提供するという2つの特徴に基づいて、アプリケーション固有のコンポーネントベースのOSです。
	これは、C言語の方言であるnesCで記述され、イベント駆動型プログラミングモデルを使用したコンポーネントベースのモジュラー設計をしています。 
	TinyOSでは、コマンド、イベント、タスクの3つの主要な抽象化が使用されています。
	コマンドはサービスを実行するための要求であり、サービスが実行されるとイベントが応答として生成され、タスクはTinyOSスケジューラが後で実行するためのコマンドまたはイベントによってポストされた関数です。 
	TinyOSコンポーネントは、アプリケーションに提供されるインターフェイスによって指定される一連のサービスです。
	モジュールと構成の2種類のコンポーネントがあります。モジュールは、コマンドとイベントを呼び出して実装するためのnesCで書かれたコードスニペットです。
	コンフィグレーションは、コンポーネントをインターフェイス経由で接続します。
	アプリケーションによって使用されるコンポーネントだけが最終的なバイナリイメージに含まれます。

	TOSThreads [40]ライブラリは、Contikiのプロトタイプと同様に、イベントベースのアプローチとスレッドベースのアプローチを組み合わせるために導入されました。 
	イベントベースのコードはカーネルスレッドで実行され、ユーザーアプリケーションはアプリケーションスレッドで実行されます。
	アプリケーションスレッドは、カーネルスレッドがアイドル状態になったときにのみ実行できます。 
	コンパイル時には、最終的なコードでの問題の削除を確実にするために、静的最適化が使用されます。
	OSとアプリケーションは、コンパイル時に1つのファイルにまとめてバンドルされています。
	Deluge [41]と呼ばれるコンポーネントは、オーバーテアで使用されます
	ネットワーク全体の再プログラミング。 新しいアプリケーションコードは複合バイナリとして配布されます。 
	多くのプロトコルはコンポーネントとして実装できます。 
	現在のバージョンのTinyOSは、多くのハードウェアプラットフォームに移植可能です。
	
	TinyOSは、WSNノードレベルの仮想化に最適なOSではありません。
	まず、プログラミングモードはイベントドリブンです
	イベントドリブンアプリケーションをプログラミングすることはしばしば困難です。
	WSN仮想化のコンテキストでは、展開時にOSとアプリケーションをバンドルすることは実現できない場合があります。
	新しいアプリケーションタスクは、仮想マシン[42]にOSイメージ全体を伝播することによってのみインストールできます。
	TinyOSはまた、アプリケーションとOSとの間に緊密な結合を持っています。
	TinyOSのタスクスケジューラはシーケンシャル（FIFOベース）であり、WSN仮想化の弱い形を意味する実行完了モードでタスクを実行します。

	TinyOSのパフォーマンス結果は、OSの重要な機能を強調しています。
	例えば、コード最適化はプログラムのコードサイズを60％も削減します。 
	タイマーコンポーネントはCPU使用率を38％削減します。 
	割り込みとタスクの切り替えには、SenSmartに比べて非常に短い時間がかかります。

<!-- ***********************************************************************************************************************  -->

	* (2) VM middleware solution

	* 面倒臭い


	* Mate (MiddleWare編)

	Maté[42]は、逐次実行をサポートし、スタックベースのバイナリコードインタープリタを使用する小さな仮想マシンです。
	これは、TinyOSを使用して、リソースが制約された初期世代のWSNノードで動作するように設計されています。
	Matéの主な目的は、センサーを再タスクするために必要な最小限のオーバーヘッドで、WSNでエネルギー効率の高いコード伝播を可能にすることです。
	これを実現するために、アプリケーションプログラムは小さなコードカプセルに分割され、単一のコマンドでWSN全体に伝播されます。
	予め定義された命令セットを有する予め定義されたアプリケーションのみが可能である。
	基本セット、sクラス、およびxクラスの3つのクラスに分割された固定セットの命令があります。
	基本的な命令には、算術演算とセンサー/ LEDの起動、sクラス命令がメモリアクセスを実行し、xクラス命令が分岐演算を実行する命令が含まれます。
	最大8つのユーザー定義命令も使用できます。
	これらのユーザ定義命令は、Matéがインストールされたときに修正する必要があり、後で変更することはできません。
	各プログラムカプセルには最大24の命令が含まれています。より大きなプログラムは、複数のカプセルで構成されています。
	停止指示に達するまで、カプセル内の指示が順次実行される。
	新しいアプリケーションコードは、ウイルスコード配布方式を使用して、コードカプセルの形でネットワークに伝播されます。
	各カプセルには、センサーノードが新しいアプリケーションコードをインストールする必要があるかどうかを判断するために使用するバージョン番号が含まれています。
	ネットワーク全体のコードの伝播は、センサノードは、コードカプセルを近隣の隣接ノードに転送し、隣接ノードにコードカプセルを転送する。 
	Matéは、通常の命令用とプログラムフローを制御する命令用の2つのスタックを維持します。
	命令が実行中の場合、新しい命令は実行できません。
	これにより、より簡単なプログラミングオプションが可能になります。 Matéは、命令が実行される前にバイトコード解釈のコストを負う。

	ノードレベルの仮想化に関して、Matéはタスクの順次実行をサポートし、元のTinyOS実装の主な欠点に対処しようとします。 
	新しいアプリケーションコードは、センサーノードのOSを置き換えることなく注入できます。
	しかし、アプリケーションはまだ密接に結合されています。
	Matéは、イベントとその結果を定義することができるシンプルなイベントドリブンネットワークに適しています。
	正の属性で終わるために、Matéはコードカプセルを使って自動的にWSNを再プログラムする簡単なメカニズムを提供します。

	Matéのパフォーマンス結果は、標準のTinyOSリリースでもMatéで実装されているアドホックルーティングプロトコルを移植することによって収集されます。 
	単純な操作（AND、rand、sense、sendrなど）の実装は、ネイティブのTinyOSよりもCPUサイクルが多く、最悪のケースではCPUサイクルが33倍、最善のケースでは1.03回です。
	Matéを使用してコードの伝播を確認するには、42個のセンサノード（グリッドパターン）の設定が使用されます。
	Matéは、新しいコードですべてのセンサーノードを再プログラムするのに120秒を少ししかかからないことがわかります。
	全体的なMatéは、それぞれの命令がTinyOSタスクとして実行されるため、オーバーヘッドが発生します。

	* VMSTAR

	VMSTAR [43]は、Javaベースのソフトウェアフレームワークです。
	アプリケーション固有の仮想マシンを構築する。
	また、WSNアプリケーションとOS自体の更新も可能です。
	VMSTARは、開発者がさまざまなハードウェアプラットフォームに移植可能な新しいアプリケーションを開発できる豊富なプログラミングインターフェイスを提供します。 
	VMSTARは、通常のJavaクラスファイルではなくコンパクトなコードファイルを生成します。
	これは、スレッドベースのアプリケーションの順次実行と同時実行の両方をサポートします。 
	このフレームワークは、BOTS [44]と呼ばれるコンポーネント言語、構成ツール、および更新メカニズムの3つの部分で構成されています。
	コンポーネント言語は、ソフトウェアシステムを指定するために使用されます。
	合成ツールは、必要なコンポーネントを選択/合成し、特定の制約を満たすためにそれらの間の依存関係を決定します。

	更新メカニズムは、行数の変更のようなプログラムコードファイル内の構造的変更ではなく実際のコーディング変更を考慮に入れるインクリメンタル更新技術[45]を使用する。
	単純なアプリケーションでは、順次スレッド実行がサポートされていますが、外部イベントからの入力を必要とする複雑なアプリケーションの場合、2つのイベントベースプログラミングモデルが定義されています。
	1つは選択モデルで、アプリケーションがイベントにサブスクライブし、対応するイベントハンドルを取得し、イベントが発生したときにそれを実行します。
	複数のイベントの場合は、それぞれの処理方法が順次実行されます。
	2番目のモデルはアクションリスナーと呼ばれ、アプリケーションがイベントハンドラを定義するのは、イベントハンドラを登録しないデフォルトのハンドラクラスをライブラリから拡張することです。
	イベントが発生すると、登録されたコールバックメソッドが呼び出されます。
	アクションリスナモデルはスレッドの同時実行を可能にしますが、この論文では選択モデルのみが実装されています。
	基地局は、アプリケーションコードのリポジトリとして、展開および更新の目的でオーケストレーターとして使用されます。
	MICAプラットフォームの基礎となるリソースへのアクセスを可能にするネイティブインタフェースも提供されています。

	ノードレベルの仮想化では、VMSTARはマルチスレッドアプリケーションタスクの同時実行をサポートしますが、提示された実装はシングルスレッドJavaアプリケーションのみをサポートします。
	プログラミングモデルはスレッドベースであり、アプリケーションをJava言語でコーディングすることができ、開発者にとってより使いやすくなります。
	並行イベントは、アクションリスナーを使用して処理できます。 
	VMSTARでは、ユーザーアプリケーションとOSの区別について説明していますが、実装例では両方が緊密に結合されています。

	VMSTARのパフォーマンス結果は、Matéよりも優れていますが、ネイティブのTinyOSではそれほど優れていません。
	例えば、そのメモリ消費量はTinyOSに比べてほぼ倍です。
	VMSTARがTinyOSとMatéの間に位置するCPU使用率についても同様です。		

	* Squawk(VMSTAR とはまた別枠なのか？)

	Squawk [46]はセンサーハードウェア上で動作する小さなJava仮想マシンです。
	VMSTARと比較して、Squawkはオペレーティングシステムを実行する必要はありません。 それ自体で必要な機能を提供します。
	これには、割り込み処理、ネットワーキング機能、リソース管理、1つのSunSpotから別のSunSpotへのアプリケーションの移行のサポート、およびデプロイされたアプリケーションの認証メカニズムが含まれます。 
	Squawkのアプリケーションは、オブジェクトとして表現され、処理されます。
	複数の独立したオブジェクトが仮想マシンに常駐できるため、並行したアプリケーションを簡単に実行できます。
	Squawk VMは、MICA / MICAZやその他のWSNプラットフォームよりも多くの処理、メモリ、ストレージ機能を持つ特定のデバイスプラットフォーム、Sun Small Programmable Object Technology（SunSpot）で動作します。
	Squawk VMは、ガベージコレクション、例外処理、ポインタの安全性、スレッドライブラリなど、多くの標準Java機能を使用できます。
	これはJ2ME CLDC [47]に準拠してJavaで書かれています。
	デバイスドライバとMAC層もJavaで記述されています。

	Squawk VMは、スプリットVMアーキテクチャをサポートしています。クラスファイルのロードは、デスクトップマシン上で実行され、そのリプレゼンテーションファイルが生成されます。
	リプレゼンテーションファイルは、SunSpotsにデプロイされて実行されます。
	これらのファイルのサイズは、標準のJavaクラスファイルよりもはるかに少ないです。
	グリーンスレッドは、マルチスレッド環境をエミュレートするために使用されます。
	スレッドは、ユーザー空間で管理、実行、スケジュールされます。
	アプリケーションのステータス（一時的な状態を含む）は、保存用のストリームにシリアル化できます。
	別のSunSpot上の別のSquawk VMがそのストリームを読み込むと、完全な状態情報とともにアプリケーションを効果的に再構成できます。
	これにより、1つのSunSpotから別のSunSpotへのアプリケーションのライブマイグレーションが可能になります。
	これは、SunSpotデバイスがバッテリ電源を使い切っている状況で非常に便利です。	

	ノードレベルの仮想化では、Squawk VMは競合他社とはかなり異なるアプローチを採用しています。
	堅牢で効率的なアプリケーション分離メカニズムが提供され、複数のアプリケーションをJavaオブジェクトとして表現および処理することができます。
	これらのオブジェクトは、Isolateクラスのインスタンスであり、使用可能なメソッドを使用して開始、一時停止、および再開できます。
	アプリケーションは、JVMによって管理される複数のスレッドを持つことができます。
	プログラミングモデルはスレッドベースであり、アプリケーションはJ2MEでコード化することができます。
	また、SunSpots上のアプリケーションのロード、アンロード、停止、および移行に使用できるOTA（Over-The-Air）プログラミングのオプションもあります。

	Squawkのパフォーマンス結果は、いくつかのベンチマークスーツと、整数と長い計算を測定する数学アプリケーションを使用して提示されます。
	メモリフットプリントの場合、SquawkとCLDCのKVMを比較すると、デバッグをサポートするSquawk VMはKVM相当のメモリより少ないメモリしか使用できないことがわかります。
	SquawkとKVMのベンチマークスーツは、CPUとメモリサイズの異なるARMプラットフォームの異なるセットで実行されていました。
	KVMはより優れたハードウェアで動作し、Squawk VMよりも優れた結果を示しました。
	Squawkで生成されたアプリケーションのスーツファイルは、標準のJavaクラスファイルとJARファイルより約37％小さいサイズです。
	
	* Agilla (mobile agent middleware ?)

	Agilla [48]は、TinyOS上で動作するモバイルエージェントベースのミドルウェアであり、VMエンジンを使用して複数のアプリケーションをラウンドロビン方式で順次実行します。
	これは、モバイルエージェントとタプルスペースプログラミングモデルを使用します。
	このミドルウェアは、WSNの自己適応型アプリケーションをサポートするように設計されています。
	アプリケーションプログラムは、モバイルエージェントとしてコード化されており、ネットワーク内の変化や監視されている物理現象に応じて、他のセンサーノードに移行することができます。
	各センサノードは、いくつかの自律移動エージェントを実行できます。
	これらの移動エージェントは、強い移動、すなわち、アプリケーションコードおよびその状態を別のセンサに転送することができる。
	弱い移行はアプリケーションコードを転送するだけです。つまり、新しい移行先で移行されたモバイルエージェントがアプリケーションを再起動します。
	エージェントは、基地局からWSNに注入され、一度に1ホップ伝搬される。
	各移動エージェントは、新しい宛先に到着し、実行を開始し、次ホップセンサノードに移行する。
	このプロセスは、WSNに新しいアプリケーションを伝播するのにかなりの時間がかかります。
	各センサノードは、タプル空間とローカルメモリとを有する。
	タプル空間では、パターンマッチング技術を使用してデータにアクセスします。
	このアプローチは、モバイルエージェントがお互いのメモリアドレスを認識できないようにします。
	モバイル・エージェントには、エージェントのID、プログラム・コード、および条件コードを格納するために使用されるスタック・スペース、ヒープおよび3つのレジスタがあります。
	クローンを含むすべてのエージェントには一意のIDがあります。プログラム・コード・レジスタは次の命令のアドレスを保持し、条件コード・レジスタは実行状態を保持する。
	
	ノードレベルの仮想化では、AgillaはTinyOSを使用して 並行性を提供するため、モバイルエージェントはラウンドロビン方式で実行されます。
	しかし、これはOSの問題です。
	なぜなら、マルチスレッドOSは並行してモバイルエージェントを実行できるため、並行性が向上するからです。 
	モバイルエージェントはTinyOSとは独立して動作します。
	タプルスペースとローカルに格納されたエージェント状態を使用すると、迅速な移行が可能になりますが、プログラマには、移行の停滞などの問題に対処するための多くの作業が残されています。
	アプリケーションがIoTなどのオンザフライでセンサノードを利用する高度に動的なWSNでは、エージェントの移行によってパフォーマンスの問題が発生する可能性があります。
	Agillaのプログラミング言語は、エージェントが低レベルのアセンブリライクな言語でプログラムされているため、別の難点です。

	パフォーマンス結果を収集するために、25個のセンサノードのテストベッドが使用されます。
	エージェントの移行は、送信元センサノードと宛先センサノード間のホップ数を変えることによって評価されます。 
	移行は最大3ホップで99％成功ですが、その後は減少し始めます。
	また、ホップ数が増えるとレイテンシが増え、5ホップの移行には1.1秒以上かかる場合があります。
	遠隔操作の経験は300ms以下である。
	
	[49]の著者は、複数の競合するアプリケーションの中に配備されたWSNの利用を促進する統合システムUMADEを提示しています。
	UMADEの主な貢献は、アプリケーションの全体的な監視品質（QoM）を向上させるためにセンサーノードを割り当てるメカニズムです。
	UMADEはTelosBモトで実装され、TinyOS上でAgilla VMを使用します。
	提案システムは、QoM属性の指定、ネットワークの変更に対応するアプリケーションの配置と再配置、QoM対応のアプリケーション割り当てアルゴリズムなどのいくつかのコンポーネントで構成されています。
	QoM属性は、分散減少および検出確率属性によって指定される。
	分散減少QoM属性は、確率的方法を使用してセンサの読みを予測するために、センサの読みの相関を利用する。
	検出確率QoM属性については、確率モデルを使用して、センサノードのグループによる事象の検出の確率を見つける。
	QoM属性がUMADEの展開前に指定できるかどうか、またはUMADEが進化するプロセスであるかどうかは、このホワイトペーパーからは明らかではありません。
	QoMawareのアプリケーション割り当てアルゴリズムでは、単純なgreedy heuristicが使用され、WSNの全体的なユーティリティーを最大限に活用します。
	アプリケーションは、アプリケーション割り当てエンジンとアプリケーション展開エンジンを使用して配備されます。
	割り当てエンジンは基地局で動作し、割り当てアルゴリズムを使用してアプリケーションに適したセンサノードを見つける。
	基地局とセンサノードの両方に存在する展開エンジンは、選択されたセンサノードにセンサアプリケーションを無線送信するために使用される。
	アプリケーションはAgilla VMで同時に実行されます。
	ネットワーク・ダイナミクスおよびセンサ・ノードの障害に対処するために、プリエンプティブ割り振りと非プリエンプティブ割り振りの両方が使用されます。
	プリエンプティブな割り当てでは、既存のアプリケーションが新しいセンサーノードに再配置されて全体的なユーティリティが増加しますが、非プリエンプティブな割り当てでは新しいセンサーノードにアプリケーションが再配置されません。
	基地局側コードはJavaで記述され、センサノードコードはnesCで記述されます。

	UMADEはノードレベルの仮想化にAgilla VMを使用します。 
	Agilla VMは、並行アプリケーション用に動的メモリ管理を提供するために拡張されています。
	UMADEにはイベント駆動型プログラミングモデルがあり、アプリケーションタスクをコード化するためにnesC言語を使用します。

	アプリケーション固有の結果は、論文（すなわち、評価目的のために実装されたアプリケーション）に示されている。
	例えば、温度監視用途の重量の増加は、その有用性を60％増加させた。
	一連のノード上で複数のアプリケーションを実行する時間は、直線的に増加します。
	UMADEはAgilla over TinyOSを使用しているため、パフォーマンスはこれらの2つのソリューションに大きく依存しています。

	* Nano-CF(macro programming framework)

	展開されたWSN上の複数のアプリケーションのネットワークプログラミングと実行のためのマクロプログラミングフレームワーク、Nano-CFが、[50]に示されています。
	Nano-CFはNano-RKオペレーティングシステム上で動作し[51]、いくつかのアプリケーションで共通のWSNインフラストラクチャを利用できます。
	Nano-CFは、レート・ハーモナイズ・スケジューリング（RHS）[52]を使用して、センサ・ノード上で実行される複数のアプリケーション・タスクからのデータ・パケットの協調配信を実現します。
	RHSはまた、データ集約を可能にし、小さなデータパケットがそれらのそれぞれのアプリケーションに送信される前に一緒に結合されることを保証する。
	Nano-CFは、Coordinated Programming Environment（CPE）層、統合層、およびランタイム層で構成される3層アーキテクチャです。
	CPE層は、ユーザ/プログラマ側に存在し、アプリケーションプログラムを書くことを可能にする
	ナノコーディネーション言語（Nano-Coordination Language：Nano-CL） Nano-CLは、Cのような構文を持つ記述言語です。そのプログラムは、サービスディスクリプタとジョブディスクリプタという2つのセクションから構成されています。
	サービス記述子セクションは、センサノードによってサービスとして実行されるタスクを有する。
	ジョブ記述子セクションには、それらを実行するノードのセットとともに複数のサービスがあります。
	プログラマは、各センサノードでサービス（タスク）が実行されるタイミングと周期レートを指定する必要があります。
	プログラムコードは、バイトコードに解析され、CPE層内のディスパッチャモジュールによってセンサノードに送信される。
	統合層は、データおよび制御パケットを処理する役割を担う。
	ゲートウェイ内の送信側モジュールとセンサーノード内の受信側モジュールで構成され、アプリケーションタスクをバイトコードで配信します。
	ランタイムレイヤは、各センサノードに存在し、基礎となるNano-RK OSの受信タスクバイトコードを変換するコードインタプリタモジュールで構成される。
	また、DSRプロトコルを使用したルーティング機能も提供します。
	データ集約モジュールは、センサノードから集約されたデータを収集し、RHSを使用してそれをユーザアプリケーションに送信する。
	提案されたアーキテクチャは、センサーAndrew [53]と呼ばれる大学キャンパスのマルチアプリケーションセンシングテストベッドを使用して評価されます。

	Nano-CFは、ノードレベルの仮想化にいくつか貢献しています。
	これにより、独立したアプリケーション開発者がcommonWSNインフラストラクチャのアプリケーションタスクを記述することができます。 各アプリケーションタスクは独立して動作し、センサOSと結合されません。
	提案されたフレームワークは、データ収集アプリケーションや複数のオンボードセンサーを持つセンサーノードに適しています。
	プログラミングモデルはイベントドリブンであり、アプリケーションは記述言語Nano-CLを使用してプログラミングされます。

	ソリューションのパフォーマンス結果は、コードインタープリタのエネルギーとオーバーヘッドをカバーします。
	RHSを使用すると、パケットが最初に集約されてから送信されるため、特に複数のアプリケーションを使用して省エネルギーを実現できます。
	しかし、パケットが大きければ大きさの問題のため集約できないため、パケットサイズはこれに影響します。
	コードインタープリタを使用する場合、余分なオーバーヘッドは約55％です。

<!--  *************************************************************************************  -->
<!-- ノードレベルの仮想化のソリューションについては一旦終わり。次からネットワークレベルの話  -->
<!--  *************************************************************************************  -->

### B. ネットワークレベルの仮想化

ネットワークレベルの仮想化アプローチは、仮想ネットワーク/オーバーレイベースのソリューションとクラスタベースのソリューションの2つのグループに分類されます。
仮想ネットワーク/オーバーレイベースのソリューションでは、仮想ネットワークとアプリケーションオーバーレイの概念を利用して、ネットワークレベルの仮想化を実現しています。
仮想ネットワーク/オーバーレイは、物理ネットワークの上に作成される論理ネットワークです。
クラスタベースのソリューションでは、物理的な
ネットワークは、接続されたグループ、すなわちクラスタにおいて一緒に働くようにグループ化される。
仮想ネットワーク/オーバーレイとは異なり、クラスタリングはネットワークの物理的分割に似ており、
1つのアプリケーションに使用され、別の部分は異なるアプリケーションによって使用されます。
クラスタ内のノードには、cluster-headやcluster-memberなどの特定のロールがあります。
通常、WSNのクラスタベースのソリューションは、動的イベントを監視するために使用されます。

図4はネットワークレベルの仮想化タイプを示し、表IIはノードレベルの仮想化を扱う既存の作業の特性を示しています。

```
memo: 図４は現実世界のWSNの上に階層的？に仮想WSNを構築している図と　WSNをClusterA,B,Cというふうにラベルわけしている図がある
```

```
memo: 表２はノードレベルの仮想化を扱う既存の作業の特性を示しているらしいがよくわからない
```

#### 4.B.1. Virtual Network / Overlay-Based Solutions (図４のaの話)

##### Khan et al.(2013)
[9]の作業では、オーバーレイを使用して、展開されたWSNの上にアプリケーション固有の仮想ネットワークを作成しています。 オーバーレイは、異なる管理ドメイン内のセンサノード間のデータ交換を可能にするために使用されます。
この作業は、WSNの展開中にアプリケーションをバンドルすることが困難な状況に適しています。
複数のエンドユーザアプリケーションがセンサノードを同時に利用できるように、3層アーキテクチャが提示されています。
最下層には、Java SunSpotsのような新世代のセンサーノードだけでなく、古いものやそれ以下のものもあります。
古いセンサノードとそれ以下のセンサノードをオーバーレイに参加させるために、Gates-to-Overlay（GTO）ノードと呼ばれる別のエンティティが組み込まれています。

これらのGTOノードの機能は、ゲートウェイやシンクノード、さらに強力なセンサノードで実装できます。
中間層は、物理センサによって実行される同時のタスクを仮想センサとして抽象化する。
これは、センサノードが複数のアプリケーションタスクを同時に実行できるという作業の基本的な前提です。
最上位レイヤは、オーバーレイとして実装されるアプリケーションで構成されます。
これらの独立したアプリケーションは、センサノード上で動作するそれぞれのタスクによって送信されたデータを利用する。
各アプリケーションには、そのオーバーレイのメンバーとしての仮想センサーとの独立したオーバーレイがあります。
この論理的なグループ化により、センサーが物理的に異なる管理ドメインに位置する場合でもデータ交換が可能になります。
このアーキテクチャは、データおよび制御メッセージのための別個の経路を有する。
火災監視シナリオを例として使用し、個人の家庭のセンサノードを使用して、火災輪郭アルゴリズムを使用して火災の進行を監視する。
センサノードは私設の家庭にあるので、互いに直接データを送信することはできません。
このようなデータ交換を容易にし、火花輪郭アルゴリズムを実行するためにオーバーレイネットワークが作成される。
著者らは、エンドノードアプリケーションが必要なセンサを選択するために使用するレジストリへのセンサノードの事前公開を前提としています。
このペーパーは実装の詳細を提供していません。
しかし、データ、制御インタフェース、およびオーバーレイに対しては、特定のプロトコルが推奨されています。

ネットワークレベルの仮想化では、アプリケーション固有のオーバーレイを使用して、センサーが通信するための堅牢で効率的なメカニズムを提供します。 
WSNにおいてDHTオーバレイを利用するいくつかの努力がなされている[54]〜[57]。
各センサーは、同時に複数のオーバーレイの一部になることができ、タスクを実行することができます。
実装の詳細がない場合、このソリューションの有効性を判断することは困難ですが、最初の導入時に想定されていない新しいアプリケーションやサービスを提供するためにWSNが利用されるIoTにはかなり関係します。
地理的に分散したWSNを組み合わせて、新しいアプリケーションのデータを提供することもできます。

この作業では評価結果は提示されていません

##### MENO(2011)

[58]の研究では、センサノードや他のIPスマートオブジェクトをエンドツーエンド通信のためにインターネットに接続するという、より広い範囲の「ネットワークオブジェクトの管理されたエコシステム（MENO）」概念について論じている従来のゲートウェイベースのアプローチ。
MENOの背後にある考え方は、物理ネットワークの上に仮想ネットワークを作成し、それによってセンサノードを含む様々なタイプのデバイスとの通信を可能にすることです。各仮想ネットワーク内では、異なるプロトコルを使用してエンドツーエンド通信が可能です。
エンドツーエンド通信が可能になると、アプリケーション開発者はセンサ、アクチュエータ、およびその他のデバイスを利用する新しいアプリケーションを作成することが可能になります。
この作業は、実装の詳細や結果なしで、概念レベルにあります。
物理的な世界をインターネットとシームレスに統合するためには、クリーンスレートのアプローチを使用することが実りあるようです。
WSNをインターネットに統合するための動機付けシナリオがいくつか提示されています。

MENOによって利用されている概念は、物事仮想ネットワーク（IoT-VN）[59]のインターネットを開発するために使用されます。
この研究では、IoT-VNのコンセプトを拘束環境および非拘束環境に適用することによって実装の詳細をいくつか示しています。
制約のある環境では、IDRAフレームワーク
[60]は、仮想ネットワークのメンバ間の仮想リンクを作成するためのネイバー検出とトンネリングメカニズムを実装するために使用されます。
制限されていない環境では、Click Router [61]が使用されます。これは、C ++ベースのフレームワーク
ネットワークパケット処理機能を実現する。 仮想リンクを介してデータをルーティングすることは、AODVプロトコルを用いて達成される。
彼らは、IoT-VN IDヘッダーとネットワークヘッダーを含むようにAODVヘッダーを拡張しました。
シンプルなpingアプリケーションは、仮想ネットワーク内のデータ交換を実証するための基本的な要求メッセージと応答メッセージを実装します。

ネットワークレベルの仮想化では、[58]と[59]の作業は、従来のネットワークのレイヤ3またはレイヤ2、およびWSNのIEEE 802.15.4を介して構築された仮想リンクの概念を使用します。
実際のプロトコルについての詳細はほとんど示されていませんが、研究者はWSNの展開を開いてインターネットに接続する動機付けのシナリオについて言及しています。
全体として、ここでは、異なるデバイス（リソースが制約され、リソースが制約されていない）を接続し、新しいアプリケーションやサービスの展開のためのエンドツーエンドの通信を可能にすることに焦点を当てています。

しかし、[58]の作業はパフォーマンス結果を提供しませんが、[59]は単純な2つのセンサテストベッドのセットアップを使用して初期の結果を示します。
あるセンサーから別のセンサーに送信されたpingコマンドのラウンドトリップ時間が表示されます。
結果は全体的には解決策に多くの洞察を与えるものではありません。

##### Virtual Sensor Networksの話

仮想センサネットワーク（VSN）を作成し、維持するための組み込みエージェントベースのアプローチが[62]に示されている。
このエージェントベースのソリューションは、Javaプログラミングサポートを提供し、プログラミングが容易なJava SunSpotデバイスの上に構築されています。
著者らはまず、VSNの作成と保守に通常使用される階層化されたアプローチの分析を提供します。
このアプローチでは、VANを作成および維持するために新しいVANレイヤが導入されますが、センサノードのスリープおよびウェイクパターンが考慮されるときは柔軟性がありません
一度に2つ以上のVSNの一部であるセンサノードは、他のセンサノードと最初に調整することなく突然スリープ状態になることはできません。
利用できない。センサノード内のレイヤは密接に結合されており、他のレイヤに影響を与えることなく変更することができないため、この作業ではエージェントベースのソリューションが提案されています。
Agent Factory Micro Edition（AFME）[63]ライブラリを使用してエージェントを作成します。
各エージェントはセンサノードに常駐し、VSNの作成と保守、および他のセンサノード上の同じVSNで動作するエージェントとの通信を担当します。
これらのエージェントは、パフォーマンスを最適化するために互いに通信できます。
AFMEはエージェント間の通信を可能にし、メッセージ交換を容易にします。 AFMEでは、ネットワーク内のエージェントの移行と複製も可能で、新しいセンサーノードがVSNに簡単に参加することができます。エージェントベースのアプローチを使用すると明らかに利点があります。これは、スリープブローカーがセンサーノードのスリープとウェイク時間について知的な判断を下すことができるためです

ネットワークレベルの仮想化では、[62]の作業は、異なるアプリケーション用にWSN上に作成された独立したVSNを考慮します。
このようなVSNを作成するために、モバイルエージェントは、アプリケーションのセンサノードをリンクする仮想トポロジを作成します。
エージェントはAFMEを使用して実装されていますが、VSNの構成と動作についての詳細はありません。

興味深いことに、この作業は、エージェントベースのアプローチのパフォーマンス結果を提供するのではなく、レイヤードアプローチのシミュレーション結果を示して、明らかな欠点を示しています。

ネットワークレベルの仮想化に関する先駆的な研究は、[19]に最初に示され、[64]および[65]に拡張された。
[19]では、WSNノードのサブセットが動的にVSNを形成します。
地理的に分散されている、異なる機能を持つ異種WSNノードを使用する、動的現象を監視するなどの属性や状況を持つアプリケーションは、VSNを活用するのに特に適しています。アプリケーションを実行するそれぞれの独立したサブセットはVSNです。
このアプローチでは、異なるノードサブセットによる動的なVSNの形成のために、異なるアプリケーションが順次実行できることは明らかです。
しかし、著者らは、これらのアプリケーションが最終的に同時にどのように実行されるかについての情報を何ら提供していない。
2つの例示的なアプリケーションが提示される。 1つは地理的に重複しているアプリケーションで、異種のWSNノードを展開して大規模な2つの異なるイベントを監視するシナリオで動作します。
各WSNは、通信やルーティングを提供するために、関心のあるイベントが存在しない地域でもリソースの共有を使用せずに導入する必要があります。
ただし、リソース共有を使用すると、他のWSNが役立ち、リソースをより効率的に使用できます。

2番目のアプリケーションは、WSNノードのサブセットを使用して動的イベントを監視する概念を示しています。
このサブセットは、イベントのダイナミクスに応じて拡大または縮小できます。
この作業では、これらのVSNの管理上の問題について説明し、VSNを作成する機能について説明します。
どのサブセットにも属していないWSNノードは、WSN操作全体の中で、たとえばデータルーティングを助けたり、エネルギーを節約するために眠ったりします。

```
memo: この二番目のアプリの話は図４のbあたりの話なのかな？
```

ネットワークレベルの仮想化では、[19]の著者はVSNを作成するための基本的な動機付けを提示します。 アプリケーション例について説明します。
しかし、この論文は詳細な内容を示しており、技術的な詳細は含まれていません。 これらのVSNを実現する方法。
このホワイトペーパーでは、WSNを共有する複数のアプリケーションの基本概念と、追加の展開を行わずに新しいアプリケーションに複数のWSNを使用する方法について説明します。

このワークも評価結果はない

#### 4.B.2. クラスターベースソリューション(図４のbの話)

VSNの作成、運用、保守を容易にするために、自己組織化ツリーベースの解決策が提示されている[64]。
イベントが検出されると、動的クラスタツリーが形成され、ノードがVSNに参加して、反応的にイベントを監視します。
このアプローチでは、VSNが動的に形成されるため、アプリケーションの順次実行が可能ですが、WSNノードによってサポートされているかどうか（またはどのように）なっているかは明確ではありません。
このアプローチでは、クラスタヘッドとVSN内の子クラスタヘッドを使用してさまざまな機能を実行します。 この構造的構成は、WSNノード間の論理的な接続性を提供し、同じイベントの2つの異なる通知が検出され、1つとして扱われることを保証する。 これは、
配備されたWSNは未知のままである。
イベントが検出されると、VSN構成メッセージを交換することによって動的クラスタツリーが形成されます。

VSNは、ユニキャスト、ブロードキャスト、およびマルチキャスト通信を提供します。
ユニキャスト通信の場合、ブロードキャストおよびマルチキャスト通信がリストを使用する間に、DNSのような階層的アドレス指定方式が使用される。
このリストは、各クラスタヘッドによって提供される子クラスタヘッドを追跡するために、各クラスタヘッドによって使用されます。
VSNを作成するための新しい階層的クラスタリングアルゴリズムが提案されています。
提案されたアルゴリズムのシミュレーションベースの性能解析は、C言語のカスタム構築シミュレータを使用して提示されます。 ただし、VSNのマージや分割などの高度なVSN機能は実装されていません

クラスタツリーメカニズムは、ネットワークレベルの仮想化を実現する方法として、アプリケーションで動作するセンサノードをグループ化するために使用されます。
この作品は[19]での作品の拡張です。 動的なツリーが形成され、センサノード間の通信もサポートされる。
提案されたスキームの実際の実装についての議論はありません。

性能結果のために、離散事象シミュレータが使用される。
3つのシナリオを実装して、異なる地域のイベントを検出し、センサノードを使用してそれらを監視します。
結果は、イベントを監視するセンサノードの増加と同様に、ホップ数の線形増加を示す。
同じリージョン内の送信元ノードと送信先ノードでイベントが発生すると、より多くのユニキャストメッセージが交換されますが、これらのメッセージはネットワークサイズの影響を受けません。 一方、別の地域でイベントが発生すると、より多くのマルチキャストメッセージが交換され、ネットワークサイズの影響を受けます。

地下のプルームを監視する概念実証研究は、[65]に示されている。これは単一のアプリケーションに基づいているため、順次または同時実行でリンクを見つけることは困難です。
著者らは、VSNを作成および維持するための現象を意識したクラスタリングアルゴリズムについても説明します。このアルゴリズムを使用すると、クラスタはダイナミック現象に近いWSNノードのグループで構成され、ライフサイクル全体にわたって頻繁にレポートされます。
これらのレポートでは、アルゴリズムは、クラスタに関連し、動的現象に近いWSNノードを選択することができ、関連性の低いWSNノードが他のアプリケーションのエネルギーを節約できます。
この技術は、関連するデータのみが送信されるため、必要なデータ報告を大幅に削減します。展開されたWSNがイベントベースであり、常にオンであるとは限らないため、重要なイベントが発生するたびに突然のデータバーストが回避されます。
このアルゴリズムは、WSNノードおよびリンクの障害に対しても復元力があります。
イベントのダイナミクス、すなわち合併または分割に適応するために、DRAGONと呼ばれる別のアルゴリズムが提示される。
イベントが検出されると、DRAGONはその場所が見つかったことを確認し、その動きを追跡する。
センサの読み取り値とWSNノードの相対的な位置は、2つのイベントが論理的に区別されたままであるか、単一のイベントにマージされるべきかどうかを判断するために使用されます。

ネットワークレベルの仮想化では、この作業は[19]と[64]に基づいています。
概念実証プロトタイプは、以前の論文で提示された概念の実行可能性を実証するために使用されていますが、1つのアプリケーションだけが実証されています。

センサが導電性プローブと同様のプルームを追跡することができたことを除いて、プロトタイプの性能結果はあまりない。

### 4.C. ハイブリッドソリューション

ハイブリッドソリューションは、ノードレベルとネットワークレベルの両方の仮想化メカニズムを組み合わせています。
Hybridソリューションは、ミドルウェアとクラスタベースのソリューション、ミドルウェアと仮想ネットワーク/オーバーレイベースのソリューション、仮想マシンと動的なグループ化ベースのソリューションの3つのタイプに分類されます。

ミドルウェアとクラスタベースのソリューションでは、ミドルウェアはノードレベルの仮想化を処理し、ネットワークレベルの仮想化はセンサノードをクラスタ化して実現します。
ミドルウェアおよび仮想ネットワーク/オーバーレイベースのソリューションでは、ミドルウェアはノードレベルの仮想化を処理し、ネットワークレベルの仮想化は仮想ネットワーク/オーバーレイを使用して実現します。
仮想マシンと動的グループ化ベースのソリューションでは、ノードレベルの仮想化は仮想マシンを使用して実現され、カスタマイズされたセンサノードグループ化スキームがネットワークレベルの仮想化に使用されます。

図5はハイブリッド仮想化ソリューションを示し、表IIIはハイブリッドソリューションの特性を示す。

```
memo: 図５　
```

#### 4.C.1. ミドルウェアとクラスタベースソリューション

[66]では、Java SunSpot [67]デバイス用のミドルウェアソリューションSensomaxが提供されています。 Sensomaxはコンポーネントベースのアプローチを採用し、データ駆動型、イベント駆動型、時間駆動型、クエリ駆動型などのいくつかの運用パラダイムを提供し、柔軟性を提供します。
Sensomaxの主な貢献は、マルチタスク、動的タスクの変更、および実行時の再プログラミングのサポートです。
ノードレベルでは、ユーザーアプリケーションはアプリケーション固有のエージェントとしてコード化されています。並行処理は、メインモノリシックカーネルを使用して実装され、センサリソースを抽象化します。
アプリケーションは、モノリシックカーネル上で動作するマイクロカーネルとして機能し、基盤となるリソースに一様な方法でアクセスします。
アプリケーションがセンサノードで実行を開始すると、対応するエージェントが実行スペースにロードされ、実行のためにキューに入れられます。
リソースアルゴリズムは、実行空間内の複数のエージェントにリソースを割り当てるために使用されます。
しかしながら、このような割り当てアルゴリズムの詳細については論じられていない。
アプリケーションエージェントは、データ駆動型、イベント駆動型、時間駆動型、クエリ駆動型、またはハイブリッド型のモデルにすることができます。

ネットワークレベルでは、配備されたWSNはセンサノードからなる複数のクラスタに分割されます。
各クラスタは、単一または複数のアプリケーション専用であり、アプリケーションプログラマによって単一のエンティティとして処理されます。
アプリケーションは、各クラスタでアプリケーション固有のエージェントを実行することにより、複数のクラスタにまたがることができます。 各クラスタは、クラスタヘッドとして動作するセンサノードと、クラスタメンバとして動作するいくつかのセンサノードとからなる。 センサノードは、2つの役割を有することができる。すなわち、センサノードは、アプリケーションのクラスタヘッドとして機能することができ、同時に、異なるアプリケーションのクラスタメンバーとなることができる。
そのような役割は、センサノードに存在するアプリケーションエージェントに依存する。
エージェントベースのアプローチは、Sensomaxのネットワークレベルの通信に使用されます。
グローバルエージェントは、異なるネットワークエンティティが互いに通信することを可能にする。

ローカルエージェントはクラスタ内通信に使用され、クラスタヘッドがクラスタメンバーと通信することができます。
システムエージェントは、クラスタヘッドを介してクラスタメンバーに構成指示を送信するために基地局によって使用される。
システムエージェントは、その場でセンサーノードを再プログラムまたは更新するために使用されます。
WSNのリソースは、グローバル、ローカル、システムの3つの主要なクラスに分かれています。
グローバルリソースには、さまざまなネットワークエンティティ間で共有されるセンサ、アクチュエータ、およびプロセスが含まれます。
ローカルリソースには、クラスタ内にあるリソースが含まれ、特定のクラスタのメンバー間でのみ共有できます。
システムリソースには、リソース状態が定義されているシステムプロパティなどの項目が含まれます。
エージェントのonehopブロードキャストは、WSNのアプリケーション固有のエージェントを伝播するために使用されます。

ノードレベルの仮想化では、SensomaxはJava SunSpotデバイスを使用して、並行アプリケーション・タスクを実行する能力を活用します。
各ユーザアプリケーションはエージェントとしてプログラムされ、複数のエージェントが単一のセンサノードに常駐することができます。 エージェントは基地局を介して提出され、ワンホップブロードキャストを使用してWSNに伝播されます。 
ネットワークレベルの仮想化では、クラスタの概念が使用されます。
WSNは複数のクラスタに分割され、それぞれに独自のクラスタヘッドがあります。
異なるネットワークエンティティ間の通信を可能にするために、異なるタイプの通信モードが提供される。

性能結果は、12個のセンサノードとシミュレータからなるテストベッドによって収集されます。
センサノードが30の同時アプリケーションを実行しているとき、各エージェントの処理時間は約200ミリ秒であることがわかる。
シミュレーションの結果は同じ傾向に従います。 サンプルアプリケーションは、さまざまな条件で温度と光のレベルをレポートします。
動的更新処理時間は、同じ数のアプリケーションでは100ミリ秒未満です。

[68]の作業は、複数のアプリケーションを実行するための複数セットのアーキテクチャモデルを提供します。
この作業はAgillaのようなエージェントの概念に基づいています。
エージェントはアプリケーション固有ではなく、ノードレベルおよびネットワークレベルの機能を制御するために使用されます。
全体的な設計目標は、複数のアプリケーションをあらかじめ定義された実行順序で実行し、機能パラメータを調整できるようにすることです。
構成エージェント（Cエージェント）は、例えば、そのサンプリング間隔を変更するために、センサノード上で動作するアプリケーションの機能パラメータを修正するために使用される。 Cエージェントは、最初にWSN内で基地局からクラスタヘッドに伝播され、次にクラスタヘッドからそのクラスタ内のセンサノードに伝播される。 WSNの展開前に、アプリケーションとその実行順序が定義されています。このステップでは、新しいアプリケーションがWSNを展開したときに同時に使用することができないため、柔軟性が制限されます。
ノードレベルでは、TinyOSは、​​TinyOS上で実行されるミドルウェアを使用して、センサーノード上でアプリケーションタスクの同時実行を提供するために使用されます。
このソリューションは、TinyOSの欠点を継承しています。アプリケーションをあらかじめ定義された順序で実行することができます。

ネットワークレベルでは、WSNをサブセットに分割するためにスコープビルディングブロックの概念[69]が使用されます。 これらのサブセット内では、アプリケーション要件に応じてノードをクラスタとしてグループ化できます。 各サブセットは1つのアプリケーションのみを実行するために専用されているため、n個のサブセットを持つWSNはn個のアプリケーションを実行します。
クラスタヘッドの役割は強力なセンサノードによって実行されるため、その場でクラスタヘッドを選択する必要はありません。
最初にWSNがデプロイされると、あらかじめ定義された順序に従って、1つのアプリケーションだけが実行を開始します。
他のサブセットのセンサーは、アプリケーションを実行する順番になるまで、エネルギーを節約するためにスリープします。 アウェイクセンサノードをスリープモードに入れたり、アウェイクセンサノードをスリープモードに入れたりすることによって、あるアプリケーションから別のアプリケーションに切り替えるために、スイッチングエージェント（S-Agent）が使用されます。
S-Agentがネットワークにどのように伝播するかについての情報はありません。

ノードレベルの仮想化の場合、このソリューションはTinyOSと同様に機能し、弱い形態の仮想化を提供します。 アプリケーションとその実行シーケンスを事前定義しても、このソリューションは非常に魅力的なものにはなりません。
ネットワークレベルの仮想化では、WSNは複数のクラスタを持つサブセットに分割されます。
ある時点で、あるサブセットのセンサノードはアクティブであり、他のノードはエネルギーを節約するためにスリープする。

このワークも評価結果はない

#### 4.C.2. ミドルウェアとバーチャルネットワーク/オーバーレイベース　ソリューション:

[70]の著者は、WSN上で複数のアプリケーションを実行するプラットフォームであるSenShareについて議論します。これは、複数のアプリケーションを同時に実行するオープンアクセスWSNの展開を許可するという問題に取り組むための最初の重要な取り組みです。
WSNインフラストラクチャ所有者とアプリケーション開発者の2つの役割が考慮されます。このように、新しいビジネスモデル、革新的なアプリケーション、WSNリソースの利用効率向上、柔軟性の可能性、コスト面でのメリットがもたらされます。
ノードレベルでは、複数のアプリケーションをサポートするために、各センサノードでハードウェア抽象化レイヤ（HAL）とノードランタイムレイヤが使用されます。
各アプリケーションは、複数のアプリケーションタスクの同時実行を可能にするマルチタスクOS上で動作するTinyOSプログラムです。
HALは各アプリケーションで共有され、TinyOSアプリケーションとセンサーハードウェアの密結合を解消し、センサーハードウェアへの共有アクセスを可能にします。
各アプリケーションは、コンパイル時にすべてのTinyOSアプリケーションにリンクされる仮想ハードウェアコントローラ（例えばLED、センサ、タイマ、ネットワークI / Oへのアクセス）を含む。

アプリケーションが例えばセンサへのアクセスを必要とするとき、対応する仮想ハードウェアコントローラは、アプリケーションとマルチタスクOSとの間のランタイム層に要求を渡す。ランタイムレイヤーはOS固有で、すべてのTinyOSアプリケーションがセンサーハードウェアにアクセスするために使用します。これは、すべてのセンサーノード内で別個のプロセスとして実行され、アプリケーションとセンサーハードウェアの間を仲介します。センサI / OとネットワークI / Oは、ランタイムレイヤの2つのコンポーネントであり、センシングコンポーネントとネットワークインタフェースにそれぞれ管理されたアクセスを可能にします。このアクセスは、複数のアプリケーションに対して非同期で許可されます。 SenShareの各アプリケーションは、それを管理するために使用される一意のIDを持っています。アプリケーションをデプロイするには、SQLのようなコマンドを使用して、アプリケーションの要件に従ってターゲットノードを選択します。その後、アプリケーションのバイナリコードが、Delugeプロトコル[71]の修正版を使用して、選択されたノードに送信されます。アプリケーションが起動して実行されると、仮想トポロジが形成されて、他のデータ/制御トラフィックとの分離が提供されます。
WSNは、TPSNプロトコル[72]を使用してグローバルに同期されます。

ネットワークレベルでは、コレクションツリープロトコル（CTP）[73]を使用して、同様のアプリケーションを実行するWSNノードをグループ化するネットワークレベルのオーバーレイが作成されます。 同様のアプリケーションを実行している物理的に分散しているグループは、単一のオーバーレイネットワークに参加できます。 CTPは、WSNのデータおよび制御メッセージをルーティングするためにも使用されます。 複数のアプリケーションからのトラフィックを分離するために、各アプリケーションパケットは、シーケンス番号、発信元アドレス、宛先アドレスとともにアプリケーションIDを含むように変更されます。
ランタイム層は、この情報をソースノードと宛先ノードでそれぞれ付加して削除します。

物理的に分散したセンサノードによってアプリケーションを実行することができます。
これらの分散センサノード（クラスタ）を単一の仮想接続ネットワークにリンクするには、仮想接続ネットワーク内のクラスタを一緒に接続するために基礎となるCTPトポロジを使用するオーバーレイ形成プロトコルが必要です。
このプロトコルは、各センサノードをそのパケットを最も近いクラスタにルーティングさせることによって機能する

ノードレベルの仮想化のために、SenShareは、マルチタスクOS上でアプリケーションタスクをTinyOSプログラムとして実装します。
プログラミングモデルはTinyOSに似ています。
仮想ハードウェアコントローラをアプリケーションに組み込むことで、ソリューションの柔軟性が低下します。開発者は、センサノードごとにハードウェアの種類を認識する必要があります。 OSとアプリケーション間のランタイムレイヤは、センサハードウェアを開発者に公開しないため、アプリケーションを即座に書き込むことはできません。
ネットワークレベルの仮想化では、SenShareはオーバーレイの概念を使用し、CTPプロトコルを使用してアプリケーションの独立したオーバーレイを作成します。

この作業のパフォーマンス結果は、アプリケーション分離ペナルティとオーバーレイ管理をカバーしています。 センサノードでのより多くの同時アプリケーションでは、同じ現象をサンプリングする単一のアプリケーションと比較して、サンプリングレートが28％低下することが観察されます。
CPU使用率も直線的に増加し、SenShareランタイムへの影響は小さくなります。
メモリ使用量についても同様です。 余分なオーバーレイトラフィックは、ネットワークトラフィックの約10％までの期間にわたって減少していることがわかります。

[10]の作業では、VITROプロジェクトのコンテキストでのノードのノードレベルおよびネットワークレベルの仮想化について説明します。
この作業の目的は、i）アプリケーションとセンサノード間のブリッジとして動作するミドルウェアを設計すること、およびii）高度なセンサノードアーキテクチャを設計することである。
ノードレベルの仮想化は、ルーティングおよびMACレイヤのさまざまなインスタンスをインスタンス化することによって実現されます。
利用可能なリソースを管理し、それらのリソースを利用する要求を満たすことを担当するノード仮想化マネージャ（NVM）が各センサノード内にあります[74]。
NVMは各層と相互作用して、センサノードの最適で安全でエネルギー効率の高い利用を保証します。
各センサノードは、その発見およびそれが提供するサービスを担うミドルウェアを有する。
このミドルウェアは、ネットワーク層の上に位置します。
ネットワーク層は、複数のルーティングインスタンスをサポートできるルーティングプロトコルを使用します。
信頼性のあるルーティングプロトコル[75]がデータをルーティングするために使用され、遅延許容ネットワークメカニズムが接続性の問題に対処するために提案されています。
各アプリケーションについて、新たに構成されたMACレイヤがインスタンス化される。

参照アーキテクチャは、いくつかの自律型WSNドメインからなるネットワークレベルで提示されます。
これらの各ドメインは、ゲートウェイノードを介してVITROサービスプロバイダに接続されています。
ゲートウェイノードは、ネットワークレベルの仮想化を提供する上で重要な役割を果たします。 VSNの作成と管理に役立つモジュールで構成されています。
ゲートウェイノードは、複数のレジストリを使用してVSNを作成および管理します。 VITROでは、ゲートウェイノードだけがVSNの一部となり、RPLなどのプロトコルを使用してそれらの間のルーティングリンクを作成することで実現できます。
個々のセンサノードは、ゲートウェイノードの機能をサポートする場合に限り、VSNの一部にすることができます。そうでない場合、ゲートウェイノードの助けを借りてVSNに参加することができます。
センサの選択やタスクの配布などの詳細については説明しません。
VSNマネージャは、サービスのネゴシエーション、セッションの確立および監視を担当します。
ゲートウェイノードと高度なセンサノードの機能アーキテクチャも、システムコンポーネント間のインタフェースの詳細とともに提示されています。
実装の詳細については議論されておらず、サービス登録やサービスネゴシエーションなどのインターフェイスや機能については推奨されていません。

ノードレベルの仮想化のために、VITROは高度なセンサーノードに依存しており、リソースの効率的な利用を可能にし、
並行アクセス。
ただし、このような機能を提供するOSについての議論はなく、また、ハードウェアプラットフォームに関する情報もありません。
詳細のほとんどは概念レベルです。 プログラミングモデル、プログラミング言語、OSなどの技術的な詳細はありません
提供されています。
ネットワークレベルの仮想化では、この作業はゲートウェイノードを介してすでにVSN対応/レガシー/独自のWSNのみを接続します。
VSN対応ネットワークを作成するメカニズムについては説明されていませんし、使用するプロトコルについても言及していません。

#### 4.C.3. Virtual Machine and Dynamic Grouping-Based solutions:

Melete [18]は、WSNにおけるアプリケーションの同時実行のためのノードレベルとネットワークレベルの両方のサポートを提供します。
ノードレベルでは、MeleteはMatéを強化して同時実行をサポートし、単一のWSNノードで複数のアプリケーションのインタリーブされた実行をサポートします。
アプリケーションコードイメージは、それぞれ専用の実行スペースが格納されています。
アプリケーションは、アプリケーションの障害が同じWSNノード上で実行されている他のアプリケーションに影響しないように、変数を互いに共有しません。 WSNノードによって実行可能な同時アプリケーションの数は、使用可能なRAMによって異なります。このペーパーの実装では、最大5つのアプリケーションをサポートしています。
Meleteは、イベント駆動型プログラミングモデルを使用します。
Meleteのもうひとつの貢献は、アプリケーションタスクコードの配布をサポートすることです。
タスクコードの配布には2つの主要な目標があります。
1つは、グループの一部であるセンサノードを選択し、それらに新しいコードを送信することです。
2番目は、それを必要とするセンサノードに反応的にコードを送信することです。
両方の目標により、関連するセンサノードのタスクコードが送信され、その不必要な伝播は阻止される。
実際のコード転送は、マルチホップ通信を使用して領域ごとに行われます。

ネットワークレベルで、Meleteは複数のアプリケーションを同時に実行するために、展開されたWSNノードの動的なグループ化をサポートしています。
サポートされているネットワークトポロジは接続されたグラフです。
WSNノードは、一度に複数の論理グループに含めることができます。各論理グループは1つのアプリケーション専用で、実装は最大16個のグループをサポートします
WSNに共存する。
新しいアプリケーションコードは、上記の設計目標を使用して、グループのメンバー間で受動的に配布されます。すべてのWSNノードはアプリケーションのバージョン情報を保持し、グループにアドバタイズします。したがって、WSNノードはアプリケーションコードの更新時期を認識します。
これにより、不要な通信を減らすことでエネルギーを節約できますが、発生する遅延を犠牲にしてエネルギーを節約できます。論理グループ内のセンサノードは、一度に1つのアプリケーションを実行するため、各アプリケーションは別のアプリケーションの実行時エラーの影響を受けません。この論文では、実際の実装結果と同様に、広範なシミュレーションベースを示しています。

ノードレベルの仮想化では、MeleteはMatéを改善しますが、アプリケーションタスクには独自のデータおよび実行スペースがあるため、限られた数のアプリケーションタスクしか同時に実行できません。
プログラミングモデルは、TinyOSのイベントドリブンアプローチに基づいています。
アプリケーションプログラムはTinyScriptで書かれています。
ネットワークレベルの仮想化には、動的なグループ化スキームが用意されています。
デフォルトでは、すべてのセンサノードは親グループのメンバーであり、コードが格納されています。
センサノードがどのように新しいグループに参加するかは、それが実行しているタスクコードによって異なります。
プログラマは、ネットワークで発生する可能性のある多くの状況を認識し、応答をプログラムする必要があります。このアプローチは柔軟性がありません。

Meleteのパフォーマンス結果には、タスクコード配布方式へのパラメータの影響の数学的分析が含まれます。 Meleteのコードサイズとメモリ消費量をMatéと比較しました。
Meleteのコードサイズは、アプリケーションが1つしかない場合でもMatéよりも大きいです。
同様に、MeleteはMatéよりも高いメモリ消費量を示します。 
動的グループ化に関する結果は、オフィス環境におけるモーショントラッキングアプリケーションの遅延を秒単位で示しています。

### 4.D. Summary

表IVは、セクション2.4で特定された要件に基づく既存の作業の評価を示しています。
いくつかのノードレベルの仮想化ソリューションがいくつか見つかりました。
初期のセンサノードでは、実装するのが簡単なので、選択したプログラミングモデルはイベントドリブンでしたが、その限界が見つかると、スレッドベースのアプローチを使用してセンサノードでより複雑で並行したタスクを実装しました。
これらすべての作品の中で、TinyOSとContikiは非常に人気があり、良いコミュニティサポートを持っています。
Contikiは現在、IoT [76]のプラットフォームとみなされており、過去10年間に多くの革新的な機能を組み込んでいます。 RIOT [25]は、異機種センサプラットフォーム上でC / C ++アプリケーションを実行するための有能なOSを設計するための新作です。

```
memo: OS別に　ノードレベル仮想化、ネットワークレベル仮想化, 割り込み優先の有無、デバイス依存の有無、 リソースの発見、資源が制約されたノードへの適用,異質性、アプリケーションタスクのセンサーを洗濯
```

ネットワークレベルの仮想化では、初期の作業ではクラスタの概念が使用されていましたが、クラスタ自体の管理は非常に困難です。
WSNのクラスタベースのソリューションに関する大部分の作業は、ルーティング、エネルギー効率、セキュリティの向上に重点を置いています。
我々は、ネットワークのダイナミクスと監視されるイベントに適応するアプリケーション固有のクラスタの作成を容易にするソリューションが必要です。
最近、ネットワークレベルの仮想化のためにオーバーレイソリューションが使用されていますが、それはまだほとんど未知の領域です。
私たちは、WSNでオーバーレイを使用することが「使えない」というわけではないことを、非常に説得力のある形で論じているような作品を持っています。
最新の研究活動は、WSN仮想化のためのハイブリッドソリューションの提供に焦点を当てています。
最近締結されたいくつかの研究プロジェクトでは、WSNの仮想化に取り組んできましたが、それらのソリューションは初期段階であり、複数の問題が残っています。
たとえば、プラットフォームに依存するソリューションもあれば、理論的で概念的なソリューションもあります。

## 5. WSN VIRTUALIZATION RESEARCH PROJECTS

このセクションでは、複数のアプリケーションによるWSNの使用を想定した関連プロジェクトを紹介します。
表Vは、これらのプロジェクトをリストし、以下の特徴に基づいて要約を提供する。

### 5.1 project aim:

全体的なプロジェクトの全体的な目的を提供します。
FRESnelとVITROは、WSNの仮想化を直接目的とした唯一の2つのプロジェクトです。
残りのプロジェクトでは、スマートシティの実現、IoTの中でのスマートヘルス、ネットワーク研究のための大規模なテストベッドの提供など、より拡張されたスコープがあります。

### 5.2 project scope

プロジェクトが学術または産業研究の一部であるか、複数のパートナーの取り組みとして開発されているかを示します。
VITRO、Smart Santander、iCore、Butlerはすべて、産業、通信、学術のパートナーの大規模なコンソーシアムを含むヨーロッパのFP7プロジェクトです。
FRESnelは英国のケンブリッジ大学とオックスフォード大学の共同プロジェクトです。

### 5.3 Virtualization level:

WSN仮想化のタイプを示します。
FRESnelとVITROは、ノードレベルとネットワークレベルの両方の仮想化を提供することを目指す2つのプロジェクトです。 CitySense、iCore、Butler、ViSEはWSNの仮想化を明示的に扱っていませんが、複数のアプリケーションによるセンサーの利用を検討しています。

### 5.4 Virtualization type

WSN仮想化の真の実現には、仮想化関連のタスクを管理するゲートウェイノードは含まれません。 代わりに、センサノード自体がそのようなタスクを処理する。
一方、ゲートウェイベースの仮想化ソリューションは、WSNを単一のノードを通じてインターネットや他のネットワークに接続されたキャピラリネットワークとして機能させます。
センサノードが感知およびスリープメカニズムを使用する可能性があるので、通信のためのゲートウェイノードの存在を除外することは困難であることに言及することは重要である。

### 5.5 Network Devices

ネットワークデバイス：これらのプロジェクトのもう一つの重要な特徴は、彼らが作業に使用するデバイスの種類です。
CitySense、Butler、ViSEはハイエンド機器を使用しています。
センサは考慮されているが、通常、処理、データストレージ、電源、接続性を補完するハイエンドのPC /ノードに接続されている。
FRESnelとVITROは通常の/通常のセンサーノードを使用します。これはWSNの仮想化に関連します。

### 5.6 Evaluation setup

ここで議論されたすべてのプロジェクトは、実際のテストベッドの設定を使用してその貢献度を評価します。 これらの設定のサイズはかなり異なります。
たとえば、Smart Santanderプロジェクトでは、4つのヨーロッパの都市に約20000ノードを展開し、研究と評価のための大規模なプラットフォームを提供します。
この巨大な設定はiCoreプロジェクトでも使用されます。
これに対し、Fresnelのキャンパス内テストベッドは35ノードあり、ViSEテストベッドは3ノードしかありません。

ViSEおよびCitySenseプロジェクトは、WSN仮想化のソリューションを提供するようには設計されていませんでしたが、重要な仮想化の概念、つまり複数のアプリケーションが展開されたWSNインフラストラクチャを利用できるようにするという概念を組み込んでいます。
Smart Santander、iCore、Butlerのプロジェクトは、IoTの実現を目指しており、さまざまな種類のセンサーとデバイスを検討しています。
VITROとFRESnelはWSN仮想化に重点を置いていますが、VITROはゲートウェイベースの仮想化を提供しますが、これはWSN仮想化の真の実現ではありません。
しかし、FRESnelプロジェクトは、WSN仮想化の真の実現を考慮していますが、プラットフォーム固有のソリューションを提供しています。
全体として、WSN仮想化の考え方は、学問的な場所だけでなく、主要な産業およびテレコムのプレイヤーからもかなりの注目を集めていることは明らかです。

## 6. Research issues

我々は、革新的なWSN仮想化ソリューションを提供するために取り組む必要のある重要な研究課題を特定します。

### 6.1 Advanced Node-Level Virtualization:

ノードレベルの仮想化は、研究コミュニティから大きな注目を集めています。
多くの点で、センサOSの一部として提供されています。
OSの上で動作するマルチスレッドOSやアプリケーション固有の仮想マシン（VM）は、アプリケーションタスクの同時実行をサポートできます。
傾向がより強力なIP-WSNに向かうにつれて、MACやルーティング層などのセンサーノードの個々のコンポーネントを仮想化するためにより多くの努力が必要です。
VITROプロジェクトはコンセプト[10]を出しましたが、これまでのところ実際の実装はありません。
PAVENET OS [33]は、有能なハードウェアを利用して効率的なOSを設計しますが、単一プラットフォームに結びついています。
センサハードウェアの最新の進歩を利用するために、RIOT OS [25]のような新鮮な手法を採用して、新しい汎用ソリューションを考案することができます。
新しいソリューションの中には、センサOSとユーザアプリケーションのタスクを分離するものがありますが、OTAのインストールや既存のタスクを妨げることなく新しいユーザタスクの更新などの機能が必要です。
この問題に取り組むための1つの解決策は、[83]のようにアプリケーションの移植性を提供するためにセンサーOSの上で動作する抽象レイヤーを設計することです。モジュラーベースのアプローチは、異機種OS、プログラミング言語、およびモデルに適用できるので、はるかに優れています。

### 6.2 Network-level virtualization

配備されたWSN上で複数のアプリケーションをサポートするためにネットワークレベルの仮想化の分野ではあまり多くの作業が行われていないため、貴重な貢献をする絶好の機会があります。
オーバーレイネットワークは、堅牢で基盤となるネットワークを変更することなく効率的に作業できるため、効率的なソリューションを提供できます。 [54]、[56]、[57]のようないくつかのソリューションは存在しますが、それらは本質的に未だ胚であり、WSNを同時に利用する複数のアプリケーションの要件を考慮しません。複数のオーバーレイが共存する必要があるため、互いに干渉し合うことを有害な方法で防止することは難しい課題です。従来、クラスタベースのアプローチは、ルーティング、エネルギー効率、管理、セキュリティの改善のためにWSNで使用されていました。仮想化されたWSN内のクラスタを管理することは自明ではありませんが、クラスタベースのソリューションは、展開されたWSNを使用して動的イベントを監視するシナリオでは非常に役立ちます。
これらのソリューションは、モバイルWSN、ロボティックおよびビークルアドホックネットワークにも役立ちます。

### 6.3 Discovery and publication

WSNでのリソースとサービスの発見と公開はすでに困難ですが、仮想化されたWSNではより洗練されたものになります。
たとえば、物理センサーと仮想センサーの間に特定の種類の関係が存在するかどうか、またそれらが迅速な公開と発見のソリューションを提供するために活用できるかどうかを調べることは興味深いでしょう。
仮想センサはオンデマンドで作成され、不要になったときに破棄されるため、効率的で堅牢でスケーラブルで管理しやすいものにする必要があります。
オンザフライでのリソースとサービスの発見と公開は、特にIoTのコンテキストでは非常に重要な機能です。
P2Pベースのアーキテクチャは、サービスを発見するための中心的なメカニズムに依存しない[84]のような解決策となり得る。
ただし、仮想化されたWSNにはそのようなソリューションは存在しません。
同様に、仮想化されたWSNのためのサービス推奨システムを開発することができます。これにより、リソースとサービスの状況に応じた検出が可能になります。
CoAPリソース発見[85]、[86]、DNS-SD [87]のような最近のIETFサービス発見プロトコルは、リソースが制約された環境で効率的な発見と公開ソリューションを設計するために使用できます。
さらに、サービスの継続性を確保するためには、WSNの条件やノードの移動性や障害に対応する新しいアルゴリズムが必要です。

### 6.4 Service composition 

仮想センサーノードを使用したサービス構成は、別の重要な研究課題です。
私たちの見解では、将来のWSNの展開には、WSNプロバイダ、仮想センサプロバイダ、サービスプロバイダ、サードパーティのアプリケーション/サービスプロバイダ、エンドユーザアプリケーションなど、複数のアクタが関与します。 クラウドベースのアプローチが解決策となりうる[88]。
WSNリソースはインフラストラクチャとしてのサービス（IaaS）として提供され、エンドユーザーにサービスを提供するためにPaaS（Platform-as-a-Service）によって使用されます。
この点で、[79]、[80]、[81]のような既存のプロジェクトは、エンドユーザーサービスに関するインスピレーションのために使用できます。
セマンティクスとオントロジーを使用してアプリケーションの要件とセンサーノードの機能に基づいてサービスを構成することで、改善されたソリューションを提供できます。 また、サービス構成では、既存のサービスまたは第三者のサービスをオンザフライで使用できることにも注意することが重要です。
そのようなサービスの典型的な例として、ロケーションサービスとマッピングサービスがあります。

### 6.5 Sensor Node selection and Task Assignment

センサ選択と課題割り当ての問題は、お互いに非常に関連しています。
アプリケーションの時間的および空間的要件に応じて適切なセンサノードを選択することは、全体的なQoM（Quality of Monitoring）システムの改善にとって重要です[21]。
より詳細なタスク割り当て問題の定式化とその解は、[89]に詳細に示されているが、同時に単一のセンサノードを使用する複数のアプリケーションの可能性を考慮していない。
コスト効率の高い市場ベースのアルゴリズムは、タスクの割り当てとリソース管理に使用されます。
しかし、提案されたアルゴリズムはOS特有のものであり（Sensomax）、その適合性を判断するためにより多くの作業が必要です。 [91]のQoS対応タスク割り当てアルゴリズムは、複数のアプリケーションのQoS要件を同時に満たしながら、センサノードの選択に新しい次元をもたらします。
アプリケーションのQoS要件を考慮するだけでなく、センサノードによって監視されているイベントの特性も考慮に入れた新しいアルゴリズムが、この分野で進歩するために必要です。

### 6.6 Application Task Dissemination

新しいアプリケーションが検討されているときに、センサノードが実行するために新しいアルゴリズムまたはアプリケーションタスクを送信する必要があると仮定することは非現実的ではない。
既存のタスクを中断することなく、シームレスに新しいタスクコードを送信する（または既存のタスクコードを更新する）ことは非常に困難です。
これの多くは、センサOSと、既存のものを妨げたり、センサノードの再起動を必要とせずに、ユーザタスクをインストールして更新する能力に依存します。別の問題は、ユーザー入力を取得してプログラミングし、実行可能コードを生成するためにコンパイルする方法です。
IoTのコンテキストでは、ユーザは、必要なプログラムをコードする技術的専門知識を有していないかもしれない。 WSNインフラストラクチャとユーザーを明確に区別する必要があります。
これは、サービスプロバイダのようなエンティティに、ユーザが簡単な方法で、例えばウェブ形式で彼女の要求を提供できるようにすることによって達成することができる。
このようにして、センサノードをプログラミングする（再）いくつかの側面のみがユーザに公開される。
入力が収集されると、サービスプロバイダはそれを物理WSNプロバイダに送信して、選択されたセンサノードの実行可能コードを生成し、それらを再プログラムすることができる。
このようなシステムには2つの利点があります.1つは、何らかの理由でセンサノードがタスクを実行できないことが原因でフィルタにかけられることです。第2に、ユーザの以前の使用パターンに基づいて、履歴データを使用してセンサノードを推奨し（再）プログラムする推奨システムを考案することができる。別のアプローチは、クラウドベースのPaaSソリューションを開発し、さまざまなセンサープラットフォームのセンサーアプリケーションタスクを開発、コンパイル、検証、テスト、および展開するために特別に設計されたツールキットを提供することです。

### 6.7 Reference Designs and Architecutures

センサからのデータ取得、エンドツーエンド通信（データ管理と計算を含む）、エンドユーザアプリケーションのサービス構成など、WSNのための包括的な仮想化プラットフォームが必要です。
このようなプラットフォームを使用すると、特定のWSNアプリケーションに最適なソリューションを見つけるために、より深くて完全な検索スペースの探索が可能になります。
さらに、この完全なフレームワークは、関連するすべての側面を包括的にモデル化して評価できるようにします。時間の機密性、QoS、QoMなどのアプリケーション要件に応じて、堅牢で客観的なソリューションを実現する分散アーキテクチャが必要です。
もう1つの重要な点は、既存のワークのほとんどが固定されたWSNに焦点を当てていますが、IoTのコンテキストでは、モバイルWSNや自発的なアドホックWSNの展開がますます多くなることが期待できます。
これらのアドホックWSNは、多数のセンサーが通信して一定時間オンデマンドサービスを提供してから終了すると作成されます。スマートフォンを使用した参加型センシングとクラウディドベースのセンシングは、アドホックWSNの2つの形式です。
スマートフォンで外部センサを利用することを目的としたこの分野での初期の研究[92]があります。
これは、アンドロイドプラットフォーム用に開発されたセンサー仮想化モジュールによって実現されます。それでも、モバイル、アドホックWSN、さらにはハイブリッドなものまで、より多くのソリューションを必要としています。

### 6.8 New Protocols Alogorithms and Simulation Tools

はじめに述べたように、最近WSN仮想化は研究コミュニティから注目を集めており、現在この分野でいくつかの新しい貢献が見られています。
例えば、[93]において、センサノードが複数の同時アプリケーションによって使用されているときのセンサノードからの送信を組み合わせた調和された伝送プロトコルが提示される。
参考文献[94]と[95]は、それぞれ配備されたWSN上の並行アプリケーションを管理するための再構成スキームと管理スキームを示しています。
最初に、そのような目的のために相当なWSNの展開を行うことができない可能性があるため、提案されたプロトコルとソリューションを分析して評価するための有能なシミュレーションツールを用意することは良い考えです。
[96]には、WSN上の複数の同時アプリケーションをシミュレートする新しいシミュレーションツールが示されています。 それは良いスタートですが、すでによく知られている、確立されたシミュレーションツールにそのようなサポートを統合するためには、より多くの努力が必要です。

### 6.9 WSN Virtualization Business Model & Standardization

WSN仮想化の広範な（そしてより商業的な）受容を可能にするためには、実行可能なビジネスモデルが必要です。
これは、WSNエンティティがWSNプロバイダ、仮想センサプロバイダ、サービスプロバイダ、サードパーティのアプリケーション/サービスプロバイダの異なる役割に分離されている場合、容易に達成できます。
既存のコンポーネントを再利用できるため、サードパーティのアプリケーションを使用すると、アプリケーションとソリューションの迅速な開発が可能になります。
このようなビジネスモデルのもう一つの利点は、この分野における標準化活動の道を開くことにあります。
WSN仮想化領域のレビューでは、さまざまなプロトコル、データ形式、エンコーディング方式、Sensor Web Enablement（SWE）[97]などのコンソーシアム主導の取り組みの調和の必要性を強く感じました。
現在のところ、これらの非互換性は、ジェネリックとオープンなソリューションを提案するための主要な障壁となっています。

### 6.10 Energy Efficient Solutions

エネルギー効率は、WSNの重要な研究分野であり続けます.WSNの仮想化が関与する場合はさらに重要です。
将来のセンサノードがより能力が高く、手際の良いものになると予測しても安全ですが、エネルギー効率の良い通信、検出、ルーティング、アプリケーションが必要です。
これまでの主な焦点は、センサーノードをできるだけ長時間スリープ状態にしてエネルギー消費を抑えることでした。
この戦略は、単純なアプリケーションではうまく機能しましたが、この傾向は新興のIoTパラダイムでは維持できません。 エネルギー収穫メカニズムは、主な代替エネルギー源としてWSNプラットフォームに組み込む必要があります。
これにより、センサノードはバッテリに加えて連続的な電源を確実に供給することができます。
エネルギー収穫メカニズムの例は、エネルギーを発生させるための振動や太陽エネルギーのような周囲エネルギーの使用である[98]。
この分野ではかなりの研究がなされているが（99）、商用プラットフォームは欠けている。

### 6.11 Access Control Authentication and Accounting

もう1つの重要な領域は、配備されたWSNリソースへの制御されたアクセスを提供することです。
IoTの文脈では、都市管理のようなエンティティによって配備されたセンサはおそらく公共アクセスを可能にするが、依然としてアクセス制御、認証および認可が必要となる。
例えば、このような配置は、公開アプリケーションと共に監視アプリケーションまたはセキュリティアプリケーションにも使用されるため、ユーザーに応じたアクセスを提供することは困難になります。
もう1つの側面は、単一の機関がWSNを大規模に展開することは実現可能ではない可能性があることである。
WSNの展開が不可能な分野では、参加型センシングを代替手段として使用することができます。
プライベートオーナーに、配備されたセンサーを共有し、リモートアクセスを許可することが課題です。
自主的な参加を促すために税還​​付や実効税率のようなインセンティブを考案する必要があります。
WSNデプロイメントを金銭的な利益のために使用することで、会計上の問題、つまりサービス契約に従ってユーザーに課金する方法が決まります。

### 6.12 WSN Virtualization Application Scenarios ans Test-Beds

スマートシティ、スマートヘルス、スマートホーム、グリーンコンピューティング、パーベイシブコンピューティングなどのドメインからのアプリケーションは、コスト効率の高いソリューションとしてWSN仮想化の概念を使用する可能性があります。
モバイルWSN、参加/群集ベースのセンシング、クラウドベースのリモートセンシング、車両ネットワークなどの新しいトレンドもこのコンセプトから利益を得ることができます。
Smart Santander [79]のようなテストベッドの設定が利用可能であることから、プロトタイピングと評価のための大規模な基礎が提供されます。

## 7. Conclusion

WSN仮想化の詳細な概要と最新の状態を紹介しました。 最初に、最先端技術をノードレベル、ネットワークレベル、ハイブリッドソリューションに分類して説明しました。
次に、各カテゴリーの現存する最先端技術を批判的に分析し、動機付けされたシナリオから導かれた一連の要件に基づいて評価しました。
このトピックに関連するいくつかの研究プロジェクトも提示された。 私たちはいくつかの重要な研究の課題とその可能な解決策について概説しました。
WSN仮想化は、IoTのコンテキストでは非常に重要です。小規模なデバイスは、これまでにない規模で複数のアプリケーションに同時にサービスを提供することが期待されていますが、この課題に対応する包括的なソリューションはまだありません。
